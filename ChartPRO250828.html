<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI 차트 분석기 Ultimate Pro v26.2</title>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@300;400;500;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <style>
        :root {
            --primary-color: #2196F3;
            --primary-dark-color: #1976D2;
            --background-color: #f0f2f5;
            --card-background: #ffffff;
            --shadow-light: rgba(0,0,0,0.05);
            --shadow-medium: rgba(0,0,0,0.1);
            --success-color: #4CAF50;
            --warning-color: #ff9800;
            --danger-color: #f44336;
        }
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Noto Sans KR', sans-serif;
            background-color: var(--background-color);
            min-height: 100vh;
            padding: 20px;
            color: #333;
        }
        .container {
            max-width: 1600px;
            margin: 0 auto;
            background: var(--card-background);
            border-radius: 20px;
            box-shadow: 0 20px 40px var(--shadow-medium);
            overflow: hidden;
            display: flex;
            flex-direction: column;
            gap: 20px;
            padding: 20px;
        }
        .header {
            background: linear-gradient(135deg, var(--primary-color), var(--primary-dark-color));
            color: white;
            padding: 40px 20px;
            text-align: center;
            border-radius: 15px;
            box-shadow: 0 10px 20px rgba(0,0,0,0.15);
        }
        .header h1 {
            font-size: 2.8rem;
            font-weight: 700;
            margin-bottom: 8px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.2);
        }
        .header p {
            font-size: 1.1rem;
            opacity: 0.9;
        }
        .upload-zone {
            border: 4px dashed var(--primary-color);
            padding: 60px;
            text-align: center;
            border-radius: 20px;
            cursor: pointer;
            background: linear-gradient(45deg, #f8faff, #e3f2fd);
            transition: all 0.3s ease;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }
        .upload-zone:hover {
            border-color: var(--primary-dark-color);
            background: linear-gradient(45deg, #e3f2fd, #bbdefb);
            transform: translateY(-2px);
            box-shadow: 0 5px 15px var(--shadow-light);
        }
        .upload-zone.dragover {
            border-color: #4CAF50;
            background: linear-gradient(45deg, #e8f5e8, #c8e6c9);
        }
        .upload-icon {
            font-size: 3rem;
            color: var(--primary-color);
            margin-bottom: 15px;
        }
        .upload-zone h3 {
            font-size: 1.5rem;
            font-weight: 500;
            margin-bottom: 5px;
            color: #333;
        }
        .upload-zone p {
            color: #666;
        }
        .controls {
            display: none;
            flex-direction: column;
            gap: 20px;
            background: linear-gradient(135deg, #fff, #f5f7fa);
            padding: 25px;
            border-radius: 15px;
            box-shadow: 0 5px 15px var(--shadow-light);
        }
        .control-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 20px;
        }
        .control-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        .control-group label {
            font-weight: 600;
            color: #555;
            font-size: 0.9rem;
        }
        .control-group input[type="number"], .control-group select {
            width: 100%;
            padding: 10px;
            border: 1px solid #e1e5e9;
            border-radius: 8px;
            font-size: 0.95rem;
            transition: border-color 0.3s;
            background-color: #fefefe;
        }
        .control-group input:focus, .control-group select:focus {
            border-color: var(--primary-color);
            outline: none;
        }
        .button-group {
            display: flex;
            gap: 15px;
            justify-content: flex-end;
            margin-top: 10px;
        }
        .apply-btn, .reset-btn {
            border: none;
            padding: 15px 30px;
            border-radius: 10px;
            cursor: pointer;
            font-weight: 600;
            font-size: 1rem;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
        }
        .apply-btn {
            background: linear-gradient(135deg, #4CAF50, #45a049);
            color: white;
        }
        .apply-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(76, 175, 80, 0.4);
        }
        .apply-btn:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        .reset-btn {
            background: linear-gradient(135deg, #ff6b6b, #e55050);
            color: white;
        }
        .reset-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(255, 107, 107, 0.4);
        }
        .loading-spin {
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }
        .analysis-container {
            display: none;
            flex-direction: column;
            gap: 20px;
        }
        .chart-container, .analysis-panel {
            background: var(--card-background);
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 10px 25px var(--shadow-medium);
        }
        .chart-tabs {
            display: none;
            gap: 10px;
            margin-bottom: 20px;
        }
        .chart-tabs button {
            padding: 10px 20px;
            border: none;
            border-radius: 25px;
            background: #e9ecef;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s;
            color: #666;
        }
        .chart-tabs button.active {
            background: linear-gradient(135deg, var(--primary-color), var(--primary-dark-color));
            color: white;
            transform: scale(1.05);
        }
        #mainChart {
            height: 500px;
        }
        .analysis-panel h2, .commentary h2, .commentary h3 {
            font-size: 1.2rem;
            margin-bottom: 15px;
            border-left: 4px solid var(--primary-color);
            padding-left: 10px;
        }
        .score-card {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            margin-bottom: 20px;
            box-shadow: 0 10px 25px rgba(102, 126, 234, 0.3);
        }
        .score-value {
            font-size: 4rem;
            font-weight: 800;
            margin-bottom: 5px;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.2);
        }
        .score-label {
            font-size: 1.5rem;
            font-weight: 600;
            opacity: 0.95;
            letter-spacing: -0.5px;
        }
        .score-mode {
            font-size: 1rem;
            opacity: 0.8;
            margin-top: 5px;
        }
        .score-confidence {
            font-size: 0.9rem;
            opacity: 0.8;
            margin-top: 8px;
        }
        .score-card.strong-buy { background: linear-gradient(135deg, #4CAF50, #45a049); }
        .score-card.buy { background: linear-gradient(135deg, #8bc34a, #7cb342); }
        .score-card.neutral { background: linear-gradient(135deg, #667eea, #764ba2); }
        .score-card.sell { background: linear-gradient(135deg, #ff8c4c, #f57c00); }
        .score-card.strong-sell { background: linear-gradient(135deg, #ff4c4c, #c62828); }
        .commentary {
            padding: 20px;
            border-radius: 10px;
            background: #fff3e0;
            border-left: 4px solid #ff9800;
            margin-bottom: 20px;
        }
        .commentary h3 {
            color: #f57c00;
            margin-bottom: 10px;
            font-size: 1.1rem;
        }
        .commentary div {
            line-height: 1.7;
            color: #333;
        }
        .commentary h2 {
            font-size: 1.1rem;
            border: none;
            padding-left: 0;
            margin-bottom: 8px;
        }
        .risk-metrics {
            background: linear-gradient(135deg, #fff3e0, #ffe0b3);
            padding: 20px;
            border-radius: 10px;
            border-left: 4px solid var(--warning-color);
            margin-bottom: 20px;
        }
        .risk-metrics h3 {
            color: #e65100;
            margin-bottom: 15px;
            font-size: 1.1rem;
        }
        .risk-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
        }
        .risk-item {
            background: rgba(255,255,255,0.7);
            padding: 12px;
            border-radius: 8px;
            text-align: center;
        }
        .risk-value {
            font-size: 1.2rem;
            font-weight: 700;
            margin-bottom: 3px;
        }
        .risk-label {
            font-size: 0.85rem;
            color: #666;
        }
        .risk-value.high { color: var(--danger-color); }
        .risk-value.medium { color: var(--warning-color); }
        .risk-value.low { color: var(--success-color); }
        .support-resistance {
            background: linear-gradient(135deg, #f0f8ff, #e6f2ff);
            padding: 15px;
            border-radius: 10px;
            border-left: 4px solid #007bff;
            margin-bottom: 20px;
        }
        .support-resistance h4 {
            color: #0056b3;
            margin-bottom: 8px;
            font-size: 1rem;
        }
        .support-resistance p {
            margin-bottom: 5px;
            line-height: 1.4;
        }
        .indicators-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }
        .indicator-card {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 10px;
            border-left: 4px solid var(--primary-color);
            box-shadow: 0 2px 5px var(--shadow-light);
        }
        .indicator-title {
            font-weight: 600;
            color: #333;
            margin-bottom: 5px;
            font-size: 0.95rem;
        }
        .indicator-value {
            font-size: 1.1rem;
            font-weight: 700;
            color: var(--primary-color);
        }
        .indicator-desc {
            font-size: 0.8rem;
            color: #666;
            margin-top: 5px;
        }
        .backtest-results, .pattern-alerts {
            padding: 20px;
            border-radius: 10px;
            margin-top: 15px;
        }
        .backtest-results {
            background: #e8f5e8;
            border-left: 4px solid #4CAF50;
        }
        .backtest-results h3 { color: #2e7d32; }
        .backtest-details {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 10px;
            margin: 15px 0;
        }
        .backtest-item {
            text-align: center;
            padding: 10px;
            background: rgba(255,255,255,0.5);
            border-radius: 8px;
        }
        .backtest-item strong {
            display: block;
            font-size: 1.1rem;
            margin-bottom: 3px;
        }
        .backtest-item span {
            font-size: 0.85rem;
            color: #666;
        }
        .pattern-alerts {
            background: #fce4ec;
            border-left: 4px solid #e91e63;
        }
        .pattern-alerts h4 { color: #c2185b; }
        .pattern-alerts .alert-item {
            padding: 5px;
            border-radius: 5px;
            margin-bottom: 5px;
        }
        .pattern-alerts .alert-item.bullish { background-color: rgba(76, 175, 80, 0.1); }
        .pattern-alerts .alert-item.bearish { background-color: rgba(244, 67, 54, 0.1); }
        .backtest-results p, .pattern-alerts p {
            color: #333;
            line-height: 1.5;
        }
        .loading {
            display: none;
            text-align: center;
            padding: 40px;
            color: #666;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }
        .loading.show { display: flex; }
        .loading .spinner {
            border: 5px solid #f3f3f3;
            border-top: 5px solid var(--primary-color);
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }
        @media (max-width: 1200px) {
            .analysis-container {
                flex-direction: column;
            }
        }
        @media (max-width: 768px) {
            .container { padding: 10px; }
            .header h1 { font-size: 2rem; }
            .header p { font-size: 1rem; }
            .upload-zone { padding: 40px 20px; }
            .upload-icon { font-size: 2.5rem; }
            .upload-zone h3 { font-size: 1.2rem; }
            .control-grid { grid-template-columns: 1fr; }
            .analysis-panel { padding: 15px; }
            .score-value { font-size: 3rem; }
            .score-label { font-size: 1.2rem; }
            .indicators-grid { grid-template-columns: 1fr; }
            .risk-grid { grid-template-columns: 1fr; }
            .backtest-details { grid-template-columns: 1fr; }
        }
    </style>
</head>
<body>

<div class="container">
    <div class="header">
        <h1>AI 차트 분석기 v26.2</h1>
        <p>선행지표 • 캔들패턴 • 대가들의 매매기법</p>
    </div>

    <div id="uploadZone" class="upload-zone">
        <i class="fas fa-file-upload upload-icon"></i>
        <h3>CSV 파일을 드래그하거나 클릭하여 업로드하세요</h3>
        <p>키움증권에서 다운로드한 일자별 데이터를 지원합니다.</p>
    </div>
    <input type="file" id="fileInput" accept=".csv" style="display:none" />

    <div id="loading" class="loading">
        <div class="spinner"></div>
        <h3>데이터 분석 중...</h3>
        <p>고급 지표 계산 및 AI 분석을 수행하고 있습니다.</p>
    </div>

    <div id="controls" class="controls">
        <div class="control-grid">
            <div class="control-group">
                <label>RSI 기간</label>
                <input type="number" id="rsiPeriod" min="5" max="30" value="14">
            </div>
            <div class="control-group">
                <label>MFI 기간</label>
                <input type="number" id="mfiPeriod" min="5" max="30" value="14">
            </div>
            <div class="control-group">
                <label>MACD Fast</label>
                <input type="number" id="macdFast" min="5" max="20" value="12">
            </div>
            <div class="control-group">
                <label>MACD Slow</label>
                <input type="number" id="macdSlow" min="20" max="35" value="26">
            </div>
            <div class="control-group">
                <label>분석 관점</label>
                <select id="analysisMode">
                    <option value="long">장기 (전체)</option>
                    <option value="mid">중기 (최근 60일)</option>
                    <option value="short">단기 (최근 20일)</option>
                </select>
            </div>
            <div class="control-group">
                <label>리스크 허용도</label>
                <select id="riskTolerance">
                    <option value="conservative">보수적 (1%)</option>
                    <option value="moderate" selected>보통 (2%)</option>
                    <option value="aggressive">공격적 (3%)</option>
                </select>
            </div>
        </div>
        <div class="button-group">
            <button class="reset-btn" id="resetBtn">
                <i class="fas fa-undo"></i> 리셋
            </button>
            <button class="apply-btn" id="applyBtn">
                <i class="fas fa-sync"></i> 분석 적용
            </button>
        </div>
    </div>

    <div id="analysisContainer" class="analysis-container">
        <div class="analysis-panel">
            <div id="scoreCard" class="score-card">
                <div class="score-value">--</div>
                <div class="score-label">분석 대기</div>
                <div class="score-mode">데이터를 업로드해주세요</div>
                <div class="score-confidence"></div>
            </div>
            
            <div class="commentary" id="commentary">
                <h3>AI 분석 코멘터리</h3>
                <p>데이터 업로드 후 상세한 분석 결과를 확인할 수 있습니다.</p>
            </div>
            
            <div class="risk-metrics" id="riskMetrics">
                <h3>리스크 분석</h3>
                <div class="risk-grid">
                    <div class="risk-item">
                        <div class="risk-value" id="volatilityValue">--</div>
                        <div class="risk-label">변동성</div>
                    </div>
                    <div class="risk-item">
                        <div class="risk-value" id="maxDrawdownValue">--</div>
                        <div class="risk-label">최대 손실</div>
                    </div>
                    <div class="risk-item">
                        <div class="risk-value" id="sharpeValue">--</div>
                        <div class="risk-label">샤프 비율</div>
                    </div>
                    <div class="risk-item">
                        <div class="risk-value" id="positionSizeValue">--</div>
                        <div class="risk-label">권장 비중</div>
                    </div>
                </div>
            </div>

            <h2>기술적 지표 분석</h2>
            <div class="indicators-grid" id="indicatorsGrid">
            </div>
            
            <h2>보조 분석</h2>
            <div class="support-resistance" id="supportResistance">
                <h4>지지 & 저항 가격</h4>
                <p><strong>1차 지지선:</strong> --</p>
                <p><strong>2차 지지선:</strong> --</p>
                <p><strong>1차 저항선:</strong> --</p>
                <p><strong>2차 저항선:</strong> --</p>
            </div>

            <div class="pattern-alerts" id="patternAlerts">
                <h4>패턴 및 신호 감지</h4>
                <p>분석 결과가 여기에 표시됩니다.</p>
            </div>
            
            <div class="backtest-results" id="backtestResults">
                <h3>개선된 백테스트 결과</h3>
                <div class="backtest-details">
                    <div class="backtest-item">
                        <strong id="totalReturnValue">--</strong>
                        <span>총 수익률</span>
                    </div>
                    <div class="backtest-item">
                        <strong id="winRateValue">--</strong>
                        <span>승률</span>
                    </div>
                    <div class="backtest-item">
                        <strong id="avgHoldingValue">--</strong>
                        <span>평균 보유일</span>
                    </div>
                    <div class="backtest-item">
                        <strong id="tradeCountValue">--</strong>
                        <span>총 거래수</span>
                    </div>
                </div>
                <p class="small-text">※ 과거 수익률이 미래 수익을 보장하지 않습니다.</p>
            </div>

        </div>
        <div class="chart-container">
            <div id="chartTabs" class="chart-tabs">
                <button id="tab-daily" class="active">일봉</button>
                <button id="tab-weekly">주봉</button>
                <button id="tab-monthly">월봉</button>
            </div>
            <div id="mainChart"></div>
        </div>
    </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/lightweight-charts@4.1.1/dist/lightweight-charts.standalone.production.min.js"></script>
<script>
    const $ = id => document.getElementById(id);
    let originalData = [], currentTF = 'daily', chart;

    function setupFileUpload() {
        const uploadZone = $('uploadZone');
        const fileInput = $('fileInput');
        uploadZone.addEventListener('click', () => fileInput.click());
        uploadZone.addEventListener('dragover', e => { e.preventDefault(); uploadZone.classList.add('dragover'); });
        uploadZone.addEventListener('dragleave', () => { uploadZone.classList.remove('dragover'); });
        uploadZone.addEventListener('drop', e => { e.preventDefault(); uploadZone.classList.remove('dragover'); if (e.dataTransfer.files.length) processFile(e.dataTransfer.files[0]); });
        fileInput.addEventListener('change', e => { if (e.target.files.length) processFile(e.target.files[0]); });
    }

    function processFile(file) {
        $('uploadZone').style.display = 'none';
        $('loading').classList.add('show');
        readCSVMultiEncoding(file, text => {
            try {
                originalData = parseKiwoomCSV(text);
                if (originalData.length === 0) throw new Error('파싱된 데이터가 없습니다. 파일 형식이 올바른지 확인해주세요.');
                $('loading').classList.remove('show');
                $('controls').style.display = 'flex';
                $('analysisContainer').style.display = 'flex';
                $('chartTabs').style.display = 'flex';
                analyzeData();
            } catch (error) {
                alert('파일 처리 오류: ' + error.message);
                $('loading').classList.remove('show');
                $('uploadZone').style.display = 'flex';
                console.error('파싱 오류:', error);
            }
        });
    }

    function parseCSVLine(line) {
        const result = [];
        let current = '';
        let inQuotes = false;
        for (let i = 0; i < line.length; i++) {
            const char = line[i];
            if (char === '"') {
                inQuotes = !inQuotes;
            } else if (char === ',' && !inQuotes) {
                result.push(current.trim());
                current = '';
            } else if (char !== '\r') {
                current += char;
            }
        }
        result.push(current.trim());
        return result;
    }

    function parseNumber(str) {
        if (!str || str === '' || str === '+') return 0;
        let cleaned = str.replace(/["']/g, '').replace(/,/g, '').replace(/[가-힣]/g, '');
        const num = parseFloat(cleaned);
        return isNaN(num) ? 0 : num;
    }

    function parseDate(dateStr) {
        if (!dateStr) return '';
        const cleaned = dateStr.replace(/[/"'\s]/g, '');
        if (cleaned.length === 8) {
            return `${cleaned.substr(0,4)}-${cleaned.substr(4,2)}-${cleaned.substr(6,2)}`;
        } else if (cleaned.includes('/')) {
            return cleaned.replace(/\//g, '-');
        }
        return cleaned;
    }

    function readCSVMultiEncoding(file, callback) {
        const encodings = ['euc-kr', 'cp949', 'utf-8', 'iso-8859-1'];
        let encodingIndex = 0;
        function tryEncoding() {
            const reader = new FileReader();
            reader.onload = () => {
                const text = reader.result;
                if (text.includes('일자') || text.includes('시가')) {
                    callback(text);
                } else {
                    encodingIndex++;
                    if (encodingIndex < encodings.length) {
                        tryEncoding();
                    } else {
                        console.warn("모든 인코딩 시도가 실패했습니다. 원본 텍스트로 진행합니다.");
                        callback(text);
                    }
                }
            };
            reader.onerror = () => {
                console.error("파일 읽기 오류 발생");
                callback("");
            };
            if (encodingIndex < encodings.length) {
                reader.readAsText(file, encodings[encodingIndex]);
            }
        }
        tryEncoding();
    }

    function parseKiwoomCSV(text) {
        const lines = text.trim().split(/\n/);
        if (lines.length < 2) return [];
        let headerLineIndex = lines.findIndex(line => line.includes('일자') && line.includes('시가') && line.includes('종가'));
        if (headerLineIndex === -1) {
            console.error("적합한 헤더 행을 찾을 수 없습니다.");
            return [];
        }
        const headers = parseCSVLine(lines[headerLineIndex]);
        const headerMap = {
            '일자': headers.indexOf('일자'), '시가': headers.indexOf('시가'), '고가': headers.indexOf('고가'), '저가': headers.indexOf('저가'), '종가': headers.indexOf('종가'),
            '거래량': headers.indexOf('거래량'), '거래대금': headers.indexOf('거래대금'), '신용비': headers.indexOf('신용비'), '개인': headers.indexOf('개인'),
            '기관': headers.indexOf('기관'), '외국인': headers.indexOf('외국인'), '외인비': headers.indexOf('외인비')
        };
        const result = [];
        for (let i = headerLineIndex + 1; i < lines.length; i++) {
            const line = lines[i].trim();
            if (!line) continue;
            const cols = parseCSVLine(line);
            if (cols.length <= Math.max(...Object.values(headerMap).filter(v => v !== -1))) continue;
            const dataPoint = {
                time: parseDate(cols[headerMap['일자']]),
                open: parseNumber(cols[headerMap['시가']]),
                high: parseNumber(cols[headerMap['고가']]),
                low: parseNumber(cols[headerMap['저가']]),
                close: parseNumber(cols[headerMap['종가']]),
                volume: parseNumber(cols[headerMap['거래량']] || '0'),
                amount: parseNumber(cols[headerMap['거래대금']] || '0'),
                credit: parseNumber(cols[headerMap['신용비']] || '0'),
                individual: parseNumber(cols[headerMap['개인']] || '0'),
                institution: parseNumber(cols[headerMap['기관']] || '0'),
                foreign: parseNumber(cols[headerMap['외국인']] || '0'),
                foreignRatio: parseNumber(cols[headerMap['외인비']] || '0')
            };
            if (dataPoint.time && dataPoint.close > 0) {
                result.push(dataPoint);
            }
        }
        result.sort((a, b) => new Date(a.time) - new Date(b.time));
        return result;
    }

    function calculateSMA(data, period) {
        const result = [];
        for (let i = period - 1; i < data.length; i++) {
            const sum = data.slice(i - period + 1, i + 1).reduce((s, d) => s + (d.value !== undefined ? d.value : d.close), 0);
            result.push({ time: data[i].time, value: sum / period });
        }
        return result;
    }

    function calculateSMAArray(array, period) {
        if (array.length < period) return [];
        const result = [];
        for (let i = period - 1; i < array.length; i++) {
            const sum = array.slice(i - period + 1, i + 1).reduce((a, b) => a + b, 0);
            result.push(sum / period);
        }
        return result;
    }

    function calculateEMAArray(array, period) {
        if (array.length < period) return [];
        const k = 2 / (period + 1);
        const smaValues = calculateSMAArray(array, period);
        if (smaValues.length === 0) return [];
        
        const result = new Array(array.length).fill(null);
        result[period - 1] = smaValues[0];
        
        for (let i = period; i < array.length; i++) {
            result[i] = array[i] * k + result[i - 1] * (1 - k);
        }
        return result;
    }

    function calculateRSI(data, period = 14) {
        if (data.length < period + 1) return [];
        const closes = data.map(d => d.close);
        let gains = 0, losses = 0;
        for (let i = 1; i <= period; i++) {
            const diff = closes[i] - closes[i - 1];
            if (diff > 0) gains += diff; else losses -= diff;
        }
        let avgGain = gains / period;
        let avgLoss = losses / period;
        const result = [];
        for (let i = period; i < closes.length; i++) {
            const diff = closes[i] - closes[i - 1];
            avgGain = (avgGain * (period - 1) + (diff > 0 ? diff : 0)) / period;
            avgLoss = (avgLoss * (period - 1) + (diff < 0 ? -diff : 0)) / period;
            const rs = avgLoss === 0 ? 100 : avgGain / avgLoss;
            const rsi = 100 - (100 / (1 + rs));
            result.push({ time: data[i].time, value: rsi, price: data[i].close });
        }
        return result;
    }

    function calculateMACD(data, fastPeriod = 12, slowPeriod = 26, signalPeriod = 9) {
        const closes = data.map(d => d.close);
        const slowEMA = calculateEMAArray(closes, slowPeriod);
        const fastEMA = calculateEMAArray(closes, fastPeriod);
        
        const macd = closes.map((_, i) =>
            (fastEMA[i] != null && slowEMA[i] != null) ? (fastEMA[i] - slowEMA[i]) : null
        );
        
        const validMacd = macd.filter(v => v !== null);
        const signalEMA = calculateEMAArray(validMacd, signalPeriod);
        
        const toSeries = (arr, startIdx = 0) => {
            return data.map((d, i) => {
                const adjIdx = i - startIdx;
                return arr[adjIdx] != null ? { time: d.time, value: arr[adjIdx] } : null;
            }).filter(Boolean);
        };
        
        const macdSeries = toSeries(macd);
        const signalSeries = toSeries(signalEMA, slowPeriod - 1 + signalPeriod - 1);
        const histogram = macdSeries.map((m, i) => {
            const sig = signalSeries[i];
            return sig ? { time: m.time, value: m.value - sig.value } : null;
        }).filter(Boolean);
        
        return { macd: macdSeries, signal: signalSeries, histogram };
    }

    function calculateADX(data, period = 14) {
        if (data.length <= period) return [];
        const tr = [], plusDM = [], minusDM = [];
        
        for (let i = 1; i < data.length; i++) {
            const high = data[i].high, low = data[i].low;
            const prevHigh = data[i - 1].high, prevLow = data[i - 1].low, prevClose = data[i - 1].close;
            
            tr.push(Math.max(high - low, Math.abs(high - prevClose), Math.abs(low - prevClose)));
            const upMove = high - prevHigh;
            const downMove = prevLow - low;
            plusDM.push(upMove > downMove && upMove > 0 ? upMove : 0);
            minusDM.push(downMove > upMove && downMove > 0 ? downMove : 0);
        }
        
        let smoothedTR = tr.slice(0, period).reduce((sum, v) => sum + v, 0);
        let smoothedPlusDM = plusDM.slice(0, period).reduce((sum, v) => sum + v, 0);
        let smoothedMinusDM = minusDM.slice(0, period).reduce((sum, v) => sum + v, 0);
        
        const dxValues = [];
        for (let i = period; i < tr.length; i++) {
            smoothedTR = smoothedTR - (smoothedTR / period) + tr[i];
            smoothedPlusDM = smoothedPlusDM - (smoothedPlusDM / period) + plusDM[i];
            smoothedMinusDM = smoothedMinusDM - (smoothedMinusDM / period) + minusDM[i];
            
            const plusDI = smoothedTR > 0 ? (smoothedPlusDM / smoothedTR) * 100 : 0;
            const minusDI = smoothedTR > 0 ? (smoothedMinusDM / smoothedTR) * 100 : 0;
            const dx = (plusDI + minusDI) > 0 ? Math.abs(plusDI - minusDI) / (plusDI + minusDI) * 100 : 0;
            dxValues.push(dx);
        }
        
        if (dxValues.length < period) return [];
        
        let adx = dxValues.slice(0, period).reduce((sum, v) => sum + v, 0) / period;
        const result = [{ time: data[period + period - 1].time, value: adx }];
        
        for (let i = period; i < dxValues.length; i++) {
            adx = ((adx * (period - 1)) + dxValues[i]) / period;
            result.push({ time: data[i + period].time, value: adx });
        }
        
        return result;
    }

    function calculateBollingerBands(data, period = 20, stdDev = 2) {
        const result = { upper: [], middle: [], lower: [] };
        for (let i = period - 1; i < data.length; i++) {
            const slice = data.slice(i - period + 1, i + 1);
            const closes = slice.map(d => d.close);
            const sma = closes.reduce((sum, close) => sum + close, 0) / period;
            const variance = closes.reduce((sum, close) => sum + Math.pow(close - sma, 2), 0) / (period - 1);
            const std = Math.sqrt(variance);
            const time = data[i].time;
            result.middle.push({ time, value: sma });
            result.upper.push({ time, value: sma + (std * stdDev) });
            result.lower.push({ time, value: sma - (std * stdDev) });
        }
        return result;
    }

    function calculateOBV(data) {
        if (data.length === 0) return [];
        let obv = 0;
        return data.map((d, i) => {
            if (i > 0) {
                const prevClose = data[i-1].close;
                if (d.close > prevClose) obv += d.volume;
                else if (d.close < prevClose) obv -= d.volume;
            }
            return { time: d.time, value: obv, price: d.close };
        });
    }

    function calculateMFI(data, period = 14) {
        if (data.length < period + 1) return [];
        const result = [];
        for (let i = period; i < data.length; i++) {
            const slice = data.slice(i - period + 1, i + 1);
            let positiveMoneyFlow = 0;
            let negativeMoneyFlow = 0;
            
            for (let j = 1; j < slice.length; j++) {
                const typicalPrice = (slice[j].high + slice[j].low + slice[j].close) / 3;
                const prevTypicalPrice = (slice[j-1].high + slice[j-1].low + slice[j-1].close) / 3;
                const moneyFlow = typicalPrice * slice[j].volume;

                if (typicalPrice > prevTypicalPrice) {
                    positiveMoneyFlow += moneyFlow;
                } else if (typicalPrice < prevTypicalPrice) {
                    negativeMoneyFlow += moneyFlow;
                }
            }
            
            if (negativeMoneyFlow === 0) {
                result.push({ time: data[i].time, value: 100, price: data[i].close });
                continue;
            }
            
            const moneyRatio = positiveMoneyFlow / negativeMoneyFlow;
            const mfi = 100 - (100 / (1 + moneyRatio));
            result.push({ time: data[i].time, value: mfi, price: data[i].close });
        }
        return result;
    }
    
    function detectCandlePatterns(data) {
        const patterns = [];
        if (data.length < 2) return patterns;

        const prev = data[data.length - 2];
        const curr = data[data.length - 1];

        if (prev.close < prev.open && curr.close > curr.open &&
            curr.open < prev.close && curr.close > prev.open) {
            patterns.push({ type: '상승장악형', description: '하락세를 압도하는 강력한 매수 신호', bullish: true });
        }

        const bodySize = Math.abs(curr.open - curr.close);
        const lowerWick = curr.open > curr.close ? curr.close - curr.low : curr.open - curr.low;
        const upperWick = curr.high - Math.max(curr.open, curr.close);
        if (lowerWick > bodySize * 2 && upperWick < bodySize) {
            patterns.push({ type: '망치형', description: '하락세의 마무리를 암시하는 반전 신호', bullish: true });
        }

        return patterns;
    }
    
    function findDivergence(priceData, indicatorData, lookback = 30) {
        const divergences = [];
        if (priceData.length < lookback || indicatorData.length < lookback) return divergences;

        const priceSlice = priceData.slice(-lookback);
        const indicatorSlice = indicatorData.slice(-lookback);

        const findPeaks = (data) => {
            const peaks = [];
            for (let i = 1; i < data.length - 1; i++) {
                if (data[i].value > data[i - 1].value && data[i].value > data[i + 1].value) {
                    peaks.push({ index: i, value: data[i].value, price: data[i].price });
                }
            }
            return peaks;
        };

        const findTroughs = (data) => {
            const troughs = [];
            for (let i = 1; i < data.length - 1; i++) {
                if (data[i].value < data[i - 1].value && data[i].value < data[i + 1].value) {
                    troughs.push({ index: i, value: data[i].value, price: data[i].price });
                }
            }
            return troughs;
        };

        const pricePeaks = findPeaks(priceSlice.map(d => ({ value: d.high, price: d.high })));
        const indicatorPeaks = findPeaks(indicatorSlice);
        if (pricePeaks.length >= 2 && indicatorPeaks.length >= 2) {
            const lastPricePeak = pricePeaks[pricePeaks.length - 1];
            const prevPricePeak = pricePeaks[pricePeaks.length - 2];
            const lastIndicatorPeak = indicatorPeaks[indicatorPeaks.length - 1];
            const prevIndicatorPeak = indicatorPeaks[indicatorPeaks.length - 2];
            
            if (lastPricePeak.price > prevPricePeak.price && lastIndicatorPeak.value < prevIndicatorPeak.value) {
                divergences.push({ type: '하락 다이버전스', description: '상승 추세 약화, 하락 전환 가능성', bullish: false });
            }
        }

        const priceTroughs = findTroughs(priceSlice.map(d => ({ value: d.low, price: d.low })));
        const indicatorTroughs = findTroughs(indicatorSlice);
        if (priceTroughs.length >= 2 && indicatorTroughs.length >= 2) {
            const lastPriceTrough = priceTroughs[priceTroughs.length - 1];
            const prevPriceTrough = priceTroughs[priceTroughs.length - 2];
            const lastIndicatorTrough = indicatorTroughs[indicatorTroughs.length - 1];
            const prevIndicatorTrough = indicatorTroughs[indicatorTroughs.length - 2];
            
            if (lastPriceTrough.price < prevPriceTrough.price && lastIndicatorTrough.value > prevIndicatorTrough.value) {
                divergences.push({ type: '상승 다이버전스', description: '하락 추세 약화, 상승 전환 가능성', bullish: true });
            }
        }
        
        return divergences;
    }

    // 추가된 로직: 차트 대가들의 매매 신호 탐지
    function detectWyckoff(data) {
        const signals = [];
        if (data.length < 50) return signals;
        
        const recentData = data.slice(-50);
        const last = recentData.length - 1;
        const avgVolumeRecent = recentData.slice(-10).reduce((sum, d) => sum + d.volume, 0) / 10;
        const avgVolumeConsolidation = recentData.slice(0, -10).reduce((sum, d) => sum + d.volume, 0) / (recentData.length - 10);
        
        const isConsolidation = () => {
            const highs = recentData.map(d => d.high);
            const lows = recentData.map(d => d.low);
            const highRange = Math.max(...highs) - Math.min(...highs);
            const avgPrice = (recentData.map(d => d.close).reduce((a,b) => a+b) / recentData.length);
            return highRange / avgPrice < 0.1;
        };
        
        // 매집 신호: 횡보 기간 중 거래량 감소 후, 강한 양봉과 함께 거래량 폭증
        if (isConsolidation() && avgVolumeRecent > avgVolumeConsolidation * 2 && recentData[last].close > recentData[last].open) {
            signals.push({ type: '와이코프 매집 신호', description: '세력의 매집 후 상승 추세 시작 가능성', bullish: true, score: 30 });
        }
        
        // 분산 신호: 고점권에서 거래량 폭증
        const recentHigh = Math.max(...data.slice(-100).map(d => d.high));
        if (data[last].high > recentHigh * 0.95 && data[last].volume > avgVolumeRecent * 2) {
            signals.push({ type: '와이코프 분산 신호', description: '고점권에서 세력의 물량 분산 가능성', bullish: false, score: -30 });
        }
        return signals;
    }
    
    function detectLivermore(data) {
        const signals = [];
        if (data.length < 50) return signals;
        
        const recentData = data.slice(-50);
        const last = recentData.length - 1;
        const avgVolume = recentData.map(d => d.volume).reduce((a,b) => a+b) / recentData.length;
        const recentHigh = Math.max(...recentData.slice(0, last - 1).map(d => d.high));
        const currentClose = recentData[last].close;
        
        // Pivot Point 매수: 최근 고점 돌파 + 거래량 증가
        if (currentClose > recentHigh && recentData[last].volume > avgVolume * 1.5) {
            signals.push({ type: '리버모어 피봇 포인트', description: '추세가 시작되는 강한 매수 신호', bullish: true, score: 25 });
        }
        return signals;
    }
    
    function detectONeil(data) {
        const signals = [];
        if (data.length < 100) return signals;
        
        // 컵 위드 핸들 패턴 탐지
        const findCupWithHandle = (d) => {
            const cupStart = Math.max(0, d.length - 100);
            const cupData = d.slice(cupStart);
            const highs = cupData.map(c => c.high);
            const minIndex = highs.indexOf(Math.min(...highs));
            
            if (minIndex <= 5 || minIndex >= highs.length - 20) return null;
            
            // 컵 형성
            const leftSide = cupData.slice(0, minIndex);
            const rightSide = cupData.slice(minIndex);
            if (rightSide.length < 10) return null;
            
            const leftHigh = Math.max(...leftSide.map(l => l.high));
            const rightHigh = Math.max(...rightSide.slice(0, -5).map(r => r.high));
            
            if (Math.abs(leftHigh - rightHigh) / leftHigh > 0.05) return null;
            
            // 핸들 형성
            const handleData = cupData.slice(highs.indexOf(rightHigh));
            const handleLow = Math.min(...handleData.map(h => h.low));
            if (handleLow < rightHigh * 0.9) return null; // 핸들 깊이 조건
            
            // 돌파
            const lastData = d[d.length - 1];
            const avgVolume = d.slice(d.length - 50, -1).map(v => v.volume).reduce((a,b) => a+b) / 49;
            if (lastData.close > rightHigh && lastData.volume > avgVolume * 1.5) {
                return true;
            }
            return null;
        };
        
        if (findCupWithHandle(data)) {
            signals.push({ type: '오닐 컵위드핸들', description: '강력한 상승 추세 진입을 알리는 패턴', bullish: true, score: 35 });
        }
        return signals;
    }

    function clusterLevels(levels, binPercent = 0.01) {
        if (!levels.length) return [];
        levels.sort((a, b) => a - b);
        const clusters = [[levels[0]]];
        
        for (let i = 1; i < levels.length; i++) {
            const prev = clusters[clusters.length - 1];
            const anchor = prev[0];
            if (Math.abs(levels[i] - anchor) / anchor <= binPercent) {
                prev.push(levels[i]);
            } else {
                clusters.push([levels[i]]);
            }
        }
        
        return clusters.map(c => c[Math.floor(c.length / 2)]);
    }

    function calculateSupportResistance(data, mode) {
        if (data.length < 10) return { support1: null, support2: null, resistance1: null, resistance2: null };
        
        let lookbackPeriod;
        switch(mode) {
            case 'short': lookbackPeriod = 20; break;
            case 'mid': lookbackPeriod = 60; break;
            case 'long': lookbackPeriod = data.length; break;
        }

        const analysisData = data.slice(-lookbackPeriod);
        if (analysisData.length < 5) return { support1: null, support2: null, resistance1: null, resistance2: null };
        const currentPrice = analysisData[analysisData.length - 1].close;

        const supportCandidates = [];
        const resistanceCandidates = [];
        
        for (let i = 2; i < analysisData.length - 2; i++) {
            const current = analysisData[i];
            const prev2 = analysisData[i-2];
            const prev1 = analysisData[i-1];
            const next1 = analysisData[i+1];
            const next2 = analysisData[i+2];
            
            if (current.low < prev2.low && current.low < prev1.low &&
                current.low < next1.low && current.low < next2.low) {
                supportCandidates.push(current.low);
            }
            
            if (current.high > prev2.high && current.high > prev1.high &&
                current.high > next1.high && current.high > next2.high) {
                resistanceCandidates.push(current.high);
            }
        }

        const sma20 = calculateSMA(analysisData, 20);
        const sma60 = calculateSMA(analysisData, Math.min(60, analysisData.length));
        
        if (sma20.length > 0) {
            const sma20Value = sma20[sma20.length - 1].value;
            if (sma20Value < currentPrice) supportCandidates.push(sma20Value);
            else resistanceCandidates.push(sma20Value);
        }
        
        if (sma60.length > 0) {
            const sma60Value = sma60[sma60.length - 1].value;
            if (sma60Value < currentPrice) supportCandidates.push(sma60Value);
            else resistanceCandidates.push(sma60Value);
        }

        const clusteredSupports = clusterLevels(supportCandidates, 0.01);
        const clusteredResistances = clusterLevels(resistanceCandidates, 0.01);
        
        let support1 = null, support2 = null;
        const validSupports = clusteredSupports.filter(s => s < currentPrice * 0.98).sort((a, b) => b - a);
        if (validSupports.length > 0) support1 = validSupports[0];
        if (validSupports.length > 1) support2 = validSupports[1];

        let resistance1 = null, resistance2 = null;
        const validResistances = clusteredResistances.filter(r => r > currentPrice * 1.02).sort((a, b) => a - b);
        if (validResistances.length > 0) resistance1 = validResistances[0];
        if (validResistances.length > 1) resistance2 = validResistances[1];

        return { support1, support2, resistance1, resistance2 };
    }

    function calculateDynamicWeights(data, period = 60) {
        if (data.length < period) return getDefaultWeights();
        
        const recentData = data.slice(-period);
        const volatility = calculateVolatility(recentData);
        const trendStrength = calculateTrendStrength(recentData);
        const volume = calculateVolumeStrength(recentData);
        
        const weights = {
            rsi: 0.1,
            mfi: 0.1,
            macd: trendStrength > 0.6 ? 0.2 : 0.15,
            adx: trendStrength > 0.5 ? 0.15 : 0.1,
            bollinger: volatility > 0.3 ? 0.15 : 0.1,
            obv: volume > 0.6 ? 0.15 : 0.1,
            volume: 0.05,
            masters: 0.25 // 새로운 대가 로직에 할당될 가중치
        };
        
        const total = Object.values(weights).reduce((sum, w) => sum + w, 0);
        Object.keys(weights).forEach(key => weights[key] /= total);
        
        return weights;
    }

    function getDefaultWeights() {
        return { rsi: 0.1, mfi: 0.1, macd: 0.15, adx: 0.1, bollinger: 0.1, obv: 0.15, volume: 0.05, masters: 0.25 };
    }

    function calculateVolatility(data, period = 20) {
        if (data.length < period) return 0;
        const returns = [];
        for (let i = 1; i < data.length; i++) {
            returns.push((data[i].close - data[i-1].close) / data[i-1].close);
        }
        const mean = returns.reduce((sum, r) => sum + r, 0) / returns.length;
        const variance = returns.reduce((sum, r) => sum + Math.pow(r - mean, 2), 0) / returns.length;
        return Math.sqrt(variance) * Math.sqrt(252);
    }

    function calculateTrendStrength(data) {
        if (data.length < 20) return 0;
        const sma20 = calculateSMA(data, 20);
        const sma60 = calculateSMA(data, Math.min(60, data.length));
        if (sma20.length === 0 || sma60.length === 0) return 0;
        
        const recent20 = sma20[sma20.length - 1].value;
        const recent60 = sma60[sma60.length - 1].value;
        return Math.abs(recent20 - recent60) / recent60;
    }

    function calculateVolumeStrength(data, period = 20) {
        if (data.length < period) return 0;
        const recentVolume = data.slice(-period).reduce((sum, d) => sum + d.volume, 0) / period;
        const totalAvgVolume = data.reduce((sum, d) => sum + d.volume, 0) / data.length;
        return totalAvgVolume > 0 ? recentVolume / totalAvgVolume : 0;
    }

    function calculateAdvancedAIScore(data, mode = 'long') {
        if (data.length < 30) return { score: 50, details: {}, confidence: 0, backtest: {}, signals: [] };
        
        let analysisData;
        if (mode === 'short') { analysisData = data.slice(-30); }
        else if (mode === 'mid') { analysisData = data.slice(-90); }
        else { analysisData = data; }

        const rsi = calculateRSI(analysisData, parseInt($('rsiPeriod').value));
        const mfi = calculateMFI(analysisData, parseInt($('mfiPeriod').value));
        const obv = calculateOBV(analysisData);
        const macd = calculateMACD(analysisData, parseInt($('macdFast').value), parseInt($('macdSlow').value));
        const adx = calculateADX(analysisData);
        const bb = calculateBollingerBands(analysisData, 20);
        
        const patterns = detectCandlePatterns(analysisData);
        const rsiDivergences = findDivergence(analysisData, rsi);
        
        // 새로운 대가들의 신호 추가
        const wyckoffSignals = detectWyckoff(analysisData);
        const livermoreSignals = detectLivermore(analysisData);
        const oNeilSignals = detectONeil(analysisData);
        
        const allSignals = [...patterns, ...rsiDivergences, ...wyckoffSignals, ...livermoreSignals, ...oNeilSignals];

        const weights = calculateDynamicWeights(analysisData);
        
        const currentPrice = analysisData[analysisData.length - 1].close;
        const currentRSI = rsi.length ? rsi[rsi.length - 1].value : 50;
        const currentMFI = mfi.length ? mfi[mfi.length - 1].value : 50;
        
        let score = 50;
        const details = {};
        
        let rsiScore = ((currentRSI - 50) / 20) * 15;
        details.rsi = `${currentRSI > 70 ? '과매수' : currentRSI < 30 ? '과매도' : '중립'} (${currentRSI.toFixed(1)})`;
        score += rsiScore * weights.rsi;
        
        let mfiScore = ((currentMFI - 50) / 25) * 20;
        details.mfi = `${currentMFI > 80 ? '자금 과열' : currentMFI < 20 ? '자금 침체' : '중립'} (${currentMFI.toFixed(1)})`;
        score += mfiScore * weights.mfi;

        let obvScore = 0;
        if(obv.length > 5) {
            const obvSma5 = calculateSMA(obv, 5);
            if(obvSma5.length > 1) {
                const recentOBVSma = obvSma5[obvSma5.length-1].value;
                const prevOBVSma = obvSma5[obvSma5.length-2].value;
                if(recentOBVSma > prevOBVSma) {
                    obvScore = 15;
                    details.obv = '상승 추세';
                } else {
                    obvScore = -10;
                    details.obv = '하락 추세';
                }
            }
        }
        score += obvScore * weights.obv;

        const currentMACD = macd.macd.length ? macd.macd[macd.macd.length - 1].value : 0;
        const currentSignal = macd.signal.length ? macd.signal[macd.signal.length - 1].value : 0;
        const macdDiff = currentMACD - currentSignal;
        const prevMACD = macd.macd.length > 1 ? macd.macd[macd.macd.length - 2].value : currentMACD;
        const prevSignal = macd.signal.length > 1 ? macd.signal[macd.signal.length - 2].value : currentSignal;
        const prevMacdDiff = prevMACD - prevSignal;
        let macdScore = 0;
        if (macdDiff > 0 && prevMacdDiff <= 0) { macdScore = 25; details.macd = '골든크로스'; }
        else if (macdDiff < 0 && prevMacdDiff >= 0) { macdScore = -20; details.macd = '데드크로스'; }
        else { macdScore = macdDiff > 0 ? 10 : -5; details.macd = macdDiff > 0 ? '상승 지속' : '하락 지속'; }
        score += macdScore * weights.macd;

        const currentADX = adx.length ? adx[adx.length - 1].value : 20;
        let adxScore = currentADX > 25 ? 10 : -5;
        details.adx = `추세강도 ${currentADX.toFixed(1)}`;
        score += adxScore * weights.adx;
        
        let bbScore = 0;
        if (bb.upper.length) {
            if (currentPrice > bb.upper[bb.upper.length - 1].value) { bbScore = -10; details.bollinger = '상단 돌파'; }
            else if (currentPrice < bb.lower[bb.lower.length - 1].value) { bbScore = 15; details.bollinger = '하단 터치'; }
            else { details.bollinger = '밴드 내 움직임'; }
        }
        score += bbScore * weights.bollinger;

        const currentData = analysisData[analysisData.length - 1];
        const avgVolume = analysisData.slice(-10).reduce((sum, d) => sum + d.volume, 0) / 10;
        let volumeScore = currentData.volume > avgVolume * 2 ? 10 : 0;
        details.volume = `평균 대비 ${(currentData.volume / avgVolume).toFixed(1)}배`;
        score += volumeScore * weights.volume;

        let eventBonus = 0;
        allSignals.forEach(signal => {
            if(signal.bullish) {
                eventBonus += signal.score || (signal.type.includes('다이버전스') ? 25 : 15);
            } else {
                eventBonus += signal.score || -25;
            }
        });
        score += eventBonus * weights.masters;
        
        score = Math.max(0, Math.min(100, score));
        
        const confidence = calculateConfidence(allSignals, analysisData.length, weights);
        const backtestResult = performAdvancedBacktest(data, mode);
        
        return {
            score,
            details,
            confidence,
            backtest: backtestResult,
            signals: allSignals,
        };
    }
    
    function calculateConfidence(signals, dataLength, weights) {
        let baseConfidence = Math.min(0.9, dataLength / 252);
        
        const strongSignals = signals.filter(s => s.bullish).length;
        
        const signalBonus = Math.min(0.3, strongSignals * 0.1);
        
        const weightValues = Object.values(weights);
        const weightVariance = weightValues.reduce((sum, w) => sum + Math.pow(w - 1/weightValues.length, 2), 0) / weightValues.length;
        const diversityBonus = Math.max(0, 0.2 - weightVariance * 2);
        
        return Math.min(1, baseConfidence + signalBonus + diversityBonus);
    }

    function performAdvancedBacktest(data, mode) {
        if (data.length < 100) return getEmptyBacktest();
        
        const riskTolerance = getRiskTolerance();
        let portfolio = { cash: 1000000, position: 0, trades: [], peak: 1000000 };
        let lookback = mode === 'short' ? 30 : mode === 'mid' ? 90 : Math.min(252, data.length);
        
        for (let i = lookback; i < data.length - 10; i++) {
            const testData = data.slice(i - lookback, i);
            const result = calculateAdvancedAIScore(testData, mode);
            
            if (result.score >= 70 && result.confidence >= 0.6 && portfolio.position === 0) {
                const entryPrice = data[i].close;
                const stopLoss = entryPrice * (1 - riskTolerance * 2);
                const takeProfit = entryPrice * (1 + riskTolerance * 4);
                
                const riskAmount = portfolio.cash * riskTolerance;
                const stopDistance = entryPrice - stopLoss;
                const positionSize = Math.floor(riskAmount / stopDistance);
                const actualInvestment = Math.min(positionSize * entryPrice, portfolio.cash * 0.3);
                
                portfolio.position = actualInvestment / entryPrice;
                portfolio.cash -= actualInvestment;
                portfolio.entryPrice = entryPrice;
                portfolio.stopLoss = stopLoss;
                portfolio.takeProfit = takeProfit;
                portfolio.entryDate = i;
            }
            
            if (portfolio.position > 0) {
                const currentPrice = data[i].close;
                const holdingDays = i - portfolio.entryDate;
                let exitReason = '';
                let shouldExit = false;
                
                if (currentPrice <= portfolio.stopLoss) {
                    shouldExit = true;
                    exitReason = 'StopLoss';
                } else if (currentPrice >= portfolio.takeProfit) {
                    shouldExit = true;
                    exitReason = 'TakeProfit';
                } else if (holdingDays >= 20) {
                    shouldExit = true;
                    exitReason = 'MaxHolding';
                } else if (result.score <= 40) {
                    shouldExit = true;
                    exitReason = 'ScoreDecline';
                }
                
                if (shouldExit) {
                    const exitValue = portfolio.position * currentPrice;
                    const pnl = exitValue - (portfolio.position * portfolio.entryPrice);
                    const returnPct = (pnl / (portfolio.position * portfolio.entryPrice)) * 100;
                    
                    portfolio.trades.push({
                        entryPrice: portfolio.entryPrice,
                        exitPrice: currentPrice,
                        entryDate: portfolio.entryDate,
                        exitDate: i,
                        holdingDays,
                        pnl,
                        returnPct,
                        exitReason
                    });
                    
                    portfolio.cash += exitValue;
                    portfolio.position = 0;
                    portfolio.peak = Math.max(portfolio.peak, portfolio.cash);
                }
            }
        }
        
        return calculateBacktestMetrics(portfolio);
    }

    function getRiskTolerance() {
        const riskLevel = $('riskTolerance').value;
        switch(riskLevel) {
            case 'conservative': return 0.01;
            case 'moderate': return 0.02;
            case 'aggressive': return 0.03;
            default: return 0.02;
        }
    }

    function getEmptyBacktest() {
        return {
            totalReturn: 0,
            winRate: 0,
            avgHoldingDays: 0,
            totalTrades: 0,
            maxDrawdown: 0,
            sharpeRatio: 0
        };
    }

    function calculateBacktestMetrics(portfolio) {
        const trades = portfolio.trades;
        if (trades.length === 0) return getEmptyBacktest();
        
        const totalReturn = ((portfolio.cash - 1000000) / 1000000) * 100;
        const winningTrades = trades.filter(t => t.pnl > 0);
        const winRate = (winningTrades.length / trades.length) * 100;
        const avgHoldingDays = trades.reduce((sum, t) => sum + t.holdingDays, 0) / trades.length;
        
        let maxDrawdown = 0;
        let peak = 1000000;
        for (const trade of trades) {
            const currentValue = portfolio.cash;
            peak = Math.max(peak, currentValue);
            const drawdown = (peak - currentValue) / peak;
            maxDrawdown = Math.max(maxDrawdown, drawdown);
        }
        
        const returns = trades.map(t => t.returnPct);
        const avgReturn = returns.reduce((sum, r) => sum + r, 0) / returns.length;
        const std = Math.sqrt(returns.reduce((sum, r) => sum + Math.pow(r - avgReturn, 2), 0) / returns.length);
        const sharpeRatio = std > 0 ? (avgReturn * Math.sqrt(252)) / (std * Math.sqrt(252)) : 0;
        
        return {
            totalReturn,
            winRate,
            avgHoldingDays,
            totalTrades: trades.length,
            maxDrawdown,
            sharpeRatio
        };
    }

    function calculateRiskMetrics(data, mode = 'long') {
        if (data.length < 30) return { volatility: 0, maxDrawdown: 0, sharpeRatio: 0, positionSize: 0 };
        
        let analysisData;
        if (mode === 'short') { analysisData = data.slice(-30); }
        else if (mode === 'mid') { analysisData = data.slice(-90); }
        else { analysisData = data.slice(-252); }
        
        const volatility = calculateVolatility(analysisData);
        const returns = calculateReturns(analysisData);
        const maxDrawdown = calculateMaxDrawdown(returns);
        const sharpeRatio = calculateSharpeRatio(returns);
        const positionSize = calculatePositionSize(volatility);
        
        return { volatility, maxDrawdown, sharpeRatio, positionSize };
    }

    function calculateReturns(data) {
        const returns = [];
        for (let i = 1; i < data.length; i++) {
            returns.push((data[i].close - data[i-1].close) / data[i-1].close);
        }
        return returns;
    }

    function calculateMaxDrawdown(returns) {
        let maxDrawdown = 0;
        let peak = 0;
        let cumulative = 1;
        
        for (const ret of returns) {
            cumulative *= (1 + ret);
            peak = Math.max(peak, cumulative);
            const drawdown = (peak - cumulative) / peak;
            maxDrawdown = Math.max(maxDrawdown, drawdown);
        }
        
        return maxDrawdown * 100;
    }

    function calculateSharpeRatio(returns) {
        const avgReturn = returns.reduce((sum, r) => sum + r, 0) / returns.length;
        const std = Math.sqrt(returns.reduce((sum, r) => sum + Math.pow(r - avgReturn, 2), 0) / returns.length);
        return std > 0 ? (avgReturn * Math.sqrt(252)) / (std * Math.sqrt(252)) : 0;
    }

    function calculatePositionSize(volatility) {
        const riskTolerance = getRiskTolerance();
        const maxRisk = riskTolerance * 100;
        return Math.min(30, maxRisk / Math.max(volatility, 0.1));
    }
    
    function generateSimpleCommentary(result) {
        const { score, details, signals, support, resistance } = result;

        const formatPrice = (price) => price ? price.toLocaleString('ko-KR') : '미확인';
        const support1 = formatPrice(support.support1);
        const resistance1 = formatPrice(resistance.resistance1);

        let summary = '';
        let rationale = [];
        let strategy = [];
        
        const bullishSignals = signals.filter(s => s.bullish);
        const bearishSignals = signals.filter(s => !s.bullish);

        if (bullishSignals.length > 0) {
            summary = '## 한 줄 요약<br>**강력한 매수 신호 포착!**';
            rationale.push('- 주요 지표들이 상승 추세를 지지하고 있습니다.');
            bullishSignals.forEach(s => {
                rationale.push(`- **'${s.type}' 신호가 감지되었습니다.** ${s.description}`);
            });
            strategy.push('- **전략:** 적극적인 매수를 고려해볼 수 있는 시점입니다.');
        } else if (bearishSignals.length > 0) {
            summary = '## 한 줄 요약<br>**매우 위험한 매도 신호 포착!**';
            rationale.push('- 가격 상승에 비해 시장의 힘이 약해지고 있습니다.');
            bearishSignals.forEach(s => {
                rationale.push(`- **'${s.type}' 신호가 감지되었습니다.** ${s.description}`);
            });
            strategy.push('- **전략:** 신규 진입은 절대 금물이며, 보유자는 즉시 비중 축소 또는 매도를 고려해야 합니다.');
        } else {
            if (score >= 60) {
                summary = '## 한 줄 요약<br>**신중하게 접근해야 할 매수 신호**';
                rationale.push('- 상승 신호가 우세하지만, 추세의 강도가 아직은 명확하지 않습니다.');
                rationale.push('- 일부 지표는 여전히 중립적이므로 변동성에 주의해야 합니다.');
                strategy.push('- **전략:** 분할 매수로 리스크를 관리하며 접근하는 것이 안전합니다.');
            } else if (score >= 40) {
                summary = '## 한 줄 요약<br>**방향성 없는 중립 및 관망 구간**';
                rationale.push('- 가격(RSI)은 중립이나, 내부 에너지(OBV, MACD)는 다소 약세를 보입니다.');
                rationale.push('- 추세가 불분명하고 변동성이 커, 섣부른 예측이 매우 위험합니다.');
                strategy.push('- **전략:** **관망이 최선**입니다. 섣부른 신규 진입은 자제해야 합니다.');
            } else {
                summary = '## 한 줄 요약<br>**리스크 관리가 필요한 매도 신호**';
                rationale.push('- 주요 모멘텀 지표들이 하락 추세로 진입했습니다.');
                rationale.push('- 지지선 이탈 가능성이 커지고 있어 주의가 필요합니다.');
                strategy.push('- **전략:** 보유 비중 축소를 고려하고, 신규 매수는 절대 금물입니다.');
            }
        }
        
        // 공통 전략 추가
        strategy.push(`- **손절 라인:** ${support1}원`);
        strategy.push(`- **1차 익절:** ${resistance1}원`);

        const rationaleHtml = rationale.length > 0 ? `## 핵심 근거<br>${rationale.join('<br>')}` : '';
        const strategyHtml = strategy.length > 0 ? `## 실전 전략<br>${strategy.join('<br>')}` : '';

        return [summary, rationaleHtml, strategyHtml]
            .filter(Boolean).join('<br><br>')
            .replace(/\n/g, '<br>');
    }

    function updatePatternAlerts(signals) {
        const alertsDiv = $('patternAlerts');
        if (signals.length > 0) {
            alertsDiv.innerHTML = `
                <h4>패턴 및 신호 감지</h4>
                ${signals.map(s => `
                    <div class="alert-item ${s.bullish ? 'bullish' : 'bearish'}">
                        <strong>${s.type}:</strong> ${s.description}
                    </div>
                `).join('')}
            `;
        } else {
            alertsDiv.innerHTML = `
                <h4>패턴 및 신호 감지</h4>
                <p>현재 뚜렷한 패턴이나 신호가 감지되지 않았습니다.</p>
            `;
        }
    }
    
    function aggregateToTimeframe(data, timeframe) {
        if (timeframe === 'daily') return data;
        const grouped = {};
        data.forEach(d => {
            const date = new Date(d.time);
            let key;
            if (timeframe === 'weekly') {
                const startOfWeek = new Date(date);
                startOfWeek.setDate(date.getDate() - date.getDay());
                key = startOfWeek.toISOString().split('T')[0];
            } else if (timeframe === 'monthly') {
                key = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}-01`;
            }
            if (!grouped[key]) {
                grouped[key] = { time: key, open: d.open, high: d.high, low: d.low, close: d.close, volume: 0, amount: 0, credit: 0, foreign: 0 };
            }
            const g = grouped[key];
            g.high = Math.max(g.high, d.high);
            g.low = Math.min(g.low, d.low);
            g.close = d.close;
            g.volume += d.volume;
            g.amount += d.amount;
            g.credit = (g.credit + d.credit) / 2;
            g.foreign = (g.foreign + d.foreign) / 2;
        });
        return Object.values(grouped).sort((a, b) => new Date(a.time) - new Date(b.time));
    }

    function renderChart(timeframe = 'daily') {
        const data = aggregateToTimeframe(originalData, timeframe);
        if (data.length === 0) return;
        if (chart) { chart.remove(); }
        chart = LightweightCharts.createChart($('mainChart'), {
            width: $('mainChart').clientWidth, height: 500,
            layout: { background: { type: 'solid', color: '#ffffff' }, textColor: '#333' },
            grid: { vertLines: { color: '#f0f0f0' }, horzLines: { color: '#f0f0f0' } },
            timeScale: { timeVisible: true, secondsVisible: false }
        });
        
        const candleSeries = chart.addCandlestickSeries({
            upColor: '#ef5350', downColor: '#2196F3',
            borderVisible: false, wickUpColor: '#ef5350', wickDownColor: '#2196F3'
        });
        candleSeries.setData(data.map(d => ({ time: d.time, open: d.open, high: d.high, low: d.low, close: d.close })));

        const sma20 = calculateSMA(data, 20);
        const sma50 = calculateSMA(data, Math.min(50, data.length));
        const sma120 = calculateSMA(data, Math.min(120, data.length));

        if (sma20.length > 0) {
            chart.addLineSeries({ color: '#2196F3', lineWidth: 2, title: 'SMA20' }).setData(sma20);
        }
        if (sma50.length > 0) {
            chart.addLineSeries({ color: '#ff9800', lineWidth: 2, title: 'SMA50' }).setData(sma50);
        }
        if (sma120.length > 0) {
            chart.addLineSeries({ color: '#4caf50', lineWidth: 2, title: 'SMA120' }).setData(sma120);
        }

        const bb = calculateBollingerBands(data, 20, 2);
        if (bb.upper.length > 0) {
            chart.addLineSeries({ color: 'rgba(33, 150, 243, 0.3)', lineWidth: 1 }).setData(bb.upper);
            chart.addLineSeries({ color: 'rgba(33, 150, 243, 0.3)', lineWidth: 1 }).setData(bb.lower);
        }

        const volumeSeries = chart.addHistogramSeries({
            color: '#26a69a', priceFormat: { type: 'volume' }, priceScaleId: ''
        });
        volumeSeries.setData(data.map(d => ({
            time: d.time,
            value: d.volume,
            color: d.close >= d.open ? '#ef535080' : '#2196F380'
        })));
        
        const { support1, support2, resistance1, resistance2 } = calculateSupportResistance(originalData, $('analysisMode').value);
        const lineData = data.map(d => ({ time: d.time }));

        if (support1 !== null) {
            chart.addLineSeries({
                color: 'rgba(33, 150, 243, 0.8)', lineWidth: 2,
                lineStyle: LightweightCharts.LineStyle.Solid, title: '1차 지지선'
            }).setData(lineData.map(d => ({ ...d, value: support1 })));
        }
        if (support2 !== null) {
            chart.addLineSeries({
                color: 'rgba(33, 150, 243, 0.5)', lineWidth: 1,
                lineStyle: LightweightCharts.LineStyle.Dotted, title: '2차 지지선'
            }).setData(lineData.map(d => ({ ...d, value: support2 })));
        }
        if (resistance1 !== null) {
            chart.addLineSeries({
                color: 'rgba(239, 83, 80, 0.8)', lineWidth: 2,
                lineStyle: LightweightCharts.LineStyle.Solid, title: '1차 저항선'
            }).setData(lineData.map(d => ({ ...d, value: resistance1 })));
        }
        if (resistance2 !== null) {
            chart.addLineSeries({
                color: 'rgba(239, 83, 80, 0.5)', lineWidth: 1,
                lineStyle: LightweightCharts.LineStyle.Dotted, title: '2차 저항선'
            }).setData(lineData.map(d => ({ ...d, value: resistance2 })));
        }
        
        chart.timeScale().fitContent();
        currentTF = timeframe;
    }

    function analyzeData() {
        if (originalData.length === 0) return;
        const applyBtn = $('applyBtn');
        const applyBtnIcon = applyBtn.querySelector('i');
        applyBtn.disabled = true;
        applyBtnIcon.classList.add('loading-spin');

        setTimeout(() => {
            const mode = $('analysisMode').value;
            const scoreResult = calculateAdvancedAIScore(originalData, mode);
            const riskMetrics = calculateRiskMetrics(originalData, mode);
            const { support1, support2, resistance1, resistance2 } = calculateSupportResistance(originalData, mode);
            
            updateScoreCard(scoreResult, mode);

            const commentaryPayload = {
                score: scoreResult.score,
                details: scoreResult.details,
                signals: scoreResult.signals,
                support: { support1, support2 },
                resistance: { resistance1, resistance2 }
            };
            const newCommentary = generateSimpleCommentary(commentaryPayload);
            updateCommentary(newCommentary);

            updateRiskMetrics(riskMetrics);
            updateIndicators(scoreResult.details);
            updateSupportResistance(support1, support2, resistance1, resistance2);
            updateBacktestResults(scoreResult.backtest);
            updatePatternAlerts(scoreResult.signals);
            
            renderChart(currentTF);

            applyBtn.disabled = false;
            applyBtnIcon.classList.remove('loading-spin');
        }, 100);
    }

    function updateScoreCard(result, mode) {
        const grade = gradeScore(result.score);
        const scoreCard = $('scoreCard');
        scoreCard.className = `score-card ${grade.class}`;
        
        const modeText = mode === 'long' ? '장기 분석' : mode === 'mid' ? '중기 분석' : '단기 분석';
        const confidenceText = `신뢰도: ${(result.confidence * 100).toFixed(0)}%`;
        
        scoreCard.innerHTML = `
            <div class="score-value">${Math.round(result.score)}</div>
            <div class="score-label">${grade.label}</div>
            <div class="score-mode">${modeText}</div>
            <div class="score-confidence">${confidenceText}</div>
        `;
    }

    function updateCommentary(commentaryText) {
        $('commentary').innerHTML = `
            <h3>AI 분석 코멘터리</h3>
            <div>${commentaryText}</div>
        `;
    }

    function updateRiskMetrics(metrics) {
        $('volatilityValue').textContent = `${(metrics.volatility * 100).toFixed(1)}%`;
        $('volatilityValue').className = `risk-value ${metrics.volatility > 0.3 ? 'high' : metrics.volatility > 0.2 ? 'medium' : 'low'}`;
        
        $('maxDrawdownValue').textContent = `${metrics.maxDrawdown.toFixed(1)}%`;
        $('maxDrawdownValue').className = `risk-value ${metrics.maxDrawdown > 20 ? 'high' : metrics.maxDrawdown > 10 ? 'medium' : 'low'}`;
        
        $('sharpeValue').textContent = metrics.sharpeRatio.toFixed(2);
        $('sharpeValue').className = `risk-value ${metrics.sharpeRatio > 1 ? 'low' : metrics.sharpeRatio > 0 ? 'medium' : 'high'}`;
        
        $('positionSizeValue').textContent = `${metrics.positionSize.toFixed(0)}%`;
        $('positionSizeValue').className = 'risk-value medium';
    }

    function updateIndicators(details) {
        const indicatorsGrid = $('indicatorsGrid');
        indicatorsGrid.innerHTML = '';
        Object.entries(details).forEach(([key, value]) => {
            const card = document.createElement('div');
            card.className = 'indicator-card';
            card.innerHTML = `
                <div class="indicator-title">${getIndicatorTitle(key)}</div>
                <div class="indicator-value">${value}</div>
                <div class="indicator-desc">${getIndicatorDescription(key)}</div>
            `;
            indicatorsGrid.appendChild(card);
        });
    }

    function updateSupportResistance(support1, support2, resistance1, resistance2) {
        const formatPrice = (price) => price ? price.toLocaleString('ko-KR') + ' 원' : '--';
        
        $('supportResistance').innerHTML = `
            <h4>지지 & 저항 가격</h4>
            <p><strong>1차 지지선:</strong> ${formatPrice(support1)}</p>
            <p><strong>2차 지지선:</strong> ${formatPrice(support2)}</p>
            <p><strong>1차 저항선:</strong> ${formatPrice(resistance1)}</p>
            <p><strong>2차 저항선:</strong> ${formatPrice(resistance2)}</p>
        `;
    }

    function updateBacktestResults(backtest) {
        $('totalReturnValue').textContent = `${backtest.totalReturn > 0 ? '+' : ''}${backtest.totalReturn.toFixed(1)}%`;
        $('winRateValue').textContent = `${backtest.winRate.toFixed(1)}%`;
        $('avgHoldingValue').textContent = `${backtest.avgHoldingDays.toFixed(1)}일`;
        $('tradeCountValue').textContent = `${backtest.totalTrades}회`;
    }
    
    function gradeScore(score) {
        if (score >= 75) return { label: '강매수', class: 'strong-buy' };
        if (score >= 60) return { label: '매수', class: 'buy' };
        if (score >= 40) return { label: '중립', class: 'neutral' };
        if (score >= 25) return { label: '매도', class: 'sell' };
        return { label: '강매도', class: 'strong-sell' };
    }

    function getIndicatorTitle(key) {
        const titles = {
            rsi: 'RSI', mfi: 'MFI', obv: 'OBV', macd: 'MACD', adx: 'ADX', bollinger: '볼린저밴드',
            volume: '거래량', foreign: '외인비중', vwap: 'VWAP'
        };
        return titles[key] || key.toUpperCase();
    }

    function getIndicatorDescription(key) {
        const descriptions = {
            rsi: '상대강도지수 - 과매수/과매도',
            mfi: '자금흐름지수 - 거래량 기반 RSI',
            obv: '누적거래량지수 - 거래량 추세',
            macd: '이동평균수렴확산 - 추세 전환',
            adx: '평균방향성지수 - 추세 강도',
            bollinger: '볼린저밴드 - 가격 변동성',
            volume: '거래량 - 시장 관심도',
        };
        return descriptions[key] || '';
    }
    
    function resetAppUI() {
        originalData = [];
        if (chart) { chart.remove(); chart = null; }
        $('controls').style.display = 'none';
        $('analysisContainer').style.display = 'none';
        $('uploadZone').style.display = 'flex';
        $('chartTabs').style.display = 'none';
        $('fileInput').value = '';
        
        const scoreCard = $('scoreCard');
        scoreCard.className = 'score-card';
        scoreCard.innerHTML = `<div class="score-value">--</div><div class="score-label">분석 대기</div>`;
        $('commentary').innerHTML = `<h3>AI 분석 코멘터리</h3><p>데이터 업로드 후 상세한 분석 결과를 확인할 수 있습니다.</p>`;
        ['volatilityValue', 'maxDrawdownValue', 'sharpeValue', 'positionSizeValue'].forEach(id => {
            $(id).textContent = '--';
            $(id).className = 'risk-value';
        });
        $('indicatorsGrid').innerHTML = '';
        $('supportResistance').innerHTML = `<h4>지지 & 저항 가격</h4><p><strong>1차 지지선:</strong> --</p><p><strong>2차 지지선:</strong> --</p><p><strong>1차 저항선:</strong> --</p><p><strong>2차 저항선:</strong> --</p>`;
        ['totalReturnValue', 'winRateValue', 'avgHoldingValue', 'tradeCountValue'].forEach(id => $(id).textContent = '--');
        $('patternAlerts').innerHTML = `<h4>패턴 및 신호 감지</h4><p>분석 결과가 여기에 표시됩니다.</p>`;
    }

    function setActiveTab(timeframe) {
        document.querySelectorAll('#chartTabs button').forEach(btn => btn.classList.remove('active'));
        $(`tab-${timeframe}`).classList.add('active');
        currentTF = timeframe;
        renderChart(currentTF);
    }
    
    let analysisTimeout;
    function debounceAnalysis() {
        clearTimeout(analysisTimeout);
        analysisTimeout = setTimeout(analyzeData, 500);
    }

    function initialize() {
        setupFileUpload();
        setupControls();
        window.addEventListener('resize', () => {
            if (chart) {
                chart.applyOptions({ width: $('mainChart').clientWidth });
            }
        });
    }

    function setupControls() {
        const controls = ['rsiPeriod', 'mfiPeriod', 'macdFast', 'macdSlow'];
        controls.forEach(id => $(id).addEventListener('input', debounceAnalysis));
        $('analysisMode').addEventListener('change', analyzeData);
        $('riskTolerance').addEventListener('change', analyzeData);
        $('applyBtn').addEventListener('click', analyzeData);
        $('resetBtn').addEventListener('click', resetAppUI);
        $('tab-daily').addEventListener('click', () => setActiveTab('daily'));
        $('tab-weekly').addEventListener('click', () => setActiveTab('weekly'));
        $('tab-monthly').addEventListener('click', () => setActiveTab('monthly'));
    }

    document.addEventListener('DOMContentLoaded', initialize);
</script>
</body>
</html>