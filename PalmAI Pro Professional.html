<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>PalmAI Pro Professional - ì¬ë¯¸ë¡œ ë³´ëŠ” ì†ê¸ˆ ë¶„ì„ ì‹œìŠ¤í…œ</title>
  <style>
    /* ===== CSS Variables & Base Styles ===== */
    :root {
      --primary: #6a11cb;
      --secondary: #2575fc;
      --success: #00b894;
      --danger: #d63031;
      --warning: #fdcb6e;
      --info: #74b9ff;
      --dark: #2d3436;
      --light: #f5f6fa;
      --text: #2c3e50;
      --border: #dfe6e9;
      --shadow: 0 5px 20px rgba(0,0,0,.1);
      --transition: all .3s cubic-bezier(.4,0,.2,1);
    }

    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Noto Sans KR', sans-serif;
      background: linear-gradient(135deg, var(--primary), var(--secondary));
      min-height: 100vh;
      color: var(--text);
      line-height: 1.6;
    }

    .main-container {
      max-width: 1400px;
      margin: 0 auto;
      padding: 20px;
    }

    .app-header {
      color: #fff;
      text-align: center;
      padding: 40px 20px;
    }

    .app-header h1 {
      font-size: 2.5rem;
      margin-bottom: 10px;
      text-shadow: 2px 2px 6px rgba(0,0,0,.25);
    }

    .app-header p {
      font-size: 1.1rem;
      opacity: .95;
    }

    /* ===== Step Navigation ===== */
    .step-navigation {
      background: #fff;
      border-radius: 20px;
      padding: 25px;
      margin-bottom: 25px;
      box-shadow: var(--shadow);
    }

    .steps {
      display: flex;
      justify-content: space-between;
      position: relative;
      margin-bottom: 20px;
    }

    .steps:before {
      content: '';
      position: absolute;
      left: 0;
      right: 0;
      top: 22px;
      height: 2px;
      background: var(--border);
    }

    .step {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 8px;
      cursor: pointer;
      z-index: 1;
    }

    .step-number {
      width: 45px;
      height: 45px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: 800;
      background: var(--light);
      border: 2px solid var(--border);
      transition: var(--transition);
    }

    .step.active .step-number {
      background: var(--primary);
      color: #fff;
      border-color: var(--primary);
      transform: scale(1.1);
    }

    .step.completed .step-number {
      background: var(--success);
      color: #fff;
      border-color: var(--success);
    }

    .step-label {
      font-size: .9rem;
      font-weight: 500;
    }

    .progress-bar {
      height: 8px;
      background: var(--border);
      border-radius: 10px;
      overflow: hidden;
    }

    .progress-fill {
      height: 100%;
      background: linear-gradient(135deg, var(--primary), var(--secondary));
      width: 20%;
      transition: width .5s;
    }

    /* ===== Content Area ===== */
    .content-area {
      background: #fff;
      border-radius: 20px;
      padding: 30px;
      box-shadow: var(--shadow);
      min-height: 600px;
    }

    .step-content {
      display: none;
    }

    .step-content.active {
      display: block;
      animation: fadeIn .3s;
    }

    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(10px); }
      to { opacity: 1; transform: translateY(0); }
    }

    /* ===== Upload Section ===== */
    .upload-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
      gap: 20px;
      margin: 25px 0;
    }

    .upload-card {
      border: 3px dashed var(--border);
      border-radius: 16px;
      padding: 40px 20px;
      text-align: center;
      position: relative;
      background: var(--light);
      transition: var(--transition);
      cursor: pointer;
    }

    .upload-card:hover {
      border-color: var(--primary);
      transform: translateY(-3px);
      box-shadow: var(--shadow);
    }

    .upload-card.has-image {
      border-style: solid;
      border-color: var(--success);
      background: #fff;
    }

    .upload-icon {
      font-size: 3rem;
      margin-bottom: 12px;
    }

    .upload-preview {
      position: absolute;
      inset: 3px;
      width: calc(100% - 6px);
      height: calc(100% - 6px);
      object-fit: cover;
      border-radius: 13px;
      opacity: 0;
      transition: opacity .3s;
      pointer-events: none;
    }

    .upload-preview.visible {
      opacity: 1;
    }

    .quality-badge {
      position: absolute;
      top: 12px;
      right: 12px;
      padding: 6px 14px;
      border-radius: 20px;
      font-size: .85rem;
      font-weight: 700;
      color: #fff;
      z-index: 2;
    }

    .quality-high { background: var(--success); }
    .quality-medium { background: var(--warning); }
    .quality-low { background: var(--danger); }

    /* ===== Form Styles ===== */
    .saju-form {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 20px;
      margin: 25px 0;
    }

    .form-group {
      display: flex;
      flex-direction: column;
      gap: 6px;
    }

    .form-control {
      padding: 12px 16px;
      border: 2px solid var(--border);
      border-radius: 10px;
      font-size: 1rem;
      transition: border-color .2s;
    }

    .form-control:focus {
      outline: 0;
      border-color: var(--primary);
      box-shadow: 0 0 0 3px rgba(106,17,203,.1);
    }

    .form-control.invalid {
      border-color: var(--danger);
      background: #fff5f5;
    }

    .hint {
      font-size: .8rem;
      color: #6b7280;
    }

    /* ===== Analysis Preview Canvas ===== */
    #palm-canvas {
      width: 100%;
      max-width: 800px;
      margin: 20px auto;
      border: 2px solid var(--border);
      border-radius: 10px;
      display: block;
      background: #f8f9fa;
    }

    /* ===== Analysis Progress ===== */
    .analysis-progress {
      margin: 30px 0;
    }

    .analysis-step {
      padding: 16px 20px;
      margin: 12px 0;
      background: var(--light);
      border-left: 4px solid var(--primary);
      border-radius: 10px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      transition: all .3s;
    }

    .analysis-step.complete {
      background: #e6f7e6;
      border-left-color: var(--success);
    }

    .progress-percentage {
      font-weight: 800;
      color: var(--primary);
      font-size: 1.1rem;
    }

    /* ===== Result Cards ===== */
    .result-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
      gap: 18px;
      margin: 25px 0;
    }

    .result-card {
      background: linear-gradient(135deg, var(--primary), var(--secondary));
      color: #fff;
      padding: 25px 20px;
      border-radius: 16px;
      text-align: center;
      transition: all .3s;
      position: relative;
      overflow: hidden;
    }

    .result-card.clickable {
      cursor: pointer;
    }

    .result-card.clickable:hover {
      transform: translateY(-5px);
      box-shadow: 0 10px 30px rgba(106,17,203,.3);
    }

    .result-card.clickable:hover::after {
      content: 'ğŸ“Š ìƒì„¸ë³´ê¸°';
      position: absolute;
      bottom: 10px;
      right: 10px;
      font-size: .8rem;
      opacity: .9;
    }

    .result-score {
      font-size: 2.5rem;
      font-weight: 900;
      margin-bottom: 8px;
    }

    .result-label {
      font-size: 1rem;
      opacity: .95;
    }

    /* ===== Expert Analysis Panel ===== */
    .expert-panel {
      background: #fff;
      border-left: 5px solid var(--primary);
      border-radius: 12px;
      padding: 25px;
      margin: 25px 0;
      box-shadow: var(--shadow);
    }

    .expert-panel h3 {
      color: var(--primary);
      margin-bottom: 15px;
      font-size: 1.3rem;
    }

    .line-analysis {
      margin: 20px 0;
      padding: 15px;
      background: var(--light);
      border-radius: 10px;
    }

    .line-analysis h4 {
      color: var(--dark);
      margin-bottom: 10px;
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .line-badge {
      display: inline-block;
      padding: 3px 8px;
      border-radius: 12px;
      font-size: 0.75rem;
      font-weight: 600;
      background: var(--primary);
      color: #fff;
    }

    .feature-list {
      list-style: none;
      padding: 0;
      margin: 10px 0;
    }

    .feature-list li {
      padding: 8px 0;
      border-bottom: 1px solid var(--border);
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .feature-label {
      font-weight: 500;
      color: var(--text);
    }

    .feature-value {
      color: var(--primary);
      font-weight: 600;
    }

    /* ===== Interpretation Section ===== */
    .interpretation-section {
      background: linear-gradient(135deg, #667eea, #764ba2);
      color: #fff;
      border-radius: 15px;
      padding: 30px;
      margin: 25px 0;
    }

    .interpretation-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
      gap: 20px;
      margin-top: 20px;
    }

    .interpretation-card {
      background: rgba(255,255,255,0.1);
      backdrop-filter: blur(10px);
      border-radius: 10px;
      padding: 20px;
      border: 1px solid rgba(255,255,255,0.2);
    }

    .interpretation-card h4 {
      margin-bottom: 12px;
      font-size: 1.1rem;
    }

    .interpretation-card p {
      font-size: 0.95rem;
      line-height: 1.6;
      opacity: 0.95;
    }

    /* ===== Buttons ===== */
    .btn {
      padding: 14px 28px;
      border: none;
      border-radius: 10px;
      font-weight: 700;
      font-size: 1rem;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      gap: 10px;
      transition: all .2s;
    }

    .btn:disabled {
      opacity: .6;
      cursor: not-allowed;
    }

    .btn-primary {
      background: linear-gradient(135deg, var(--primary), var(--secondary));
      color: #fff;
    }

    .btn-primary:hover:not(:disabled) {
      transform: translateY(-2px);
      box-shadow: 0 8px 20px rgba(106,17,203,.3);
    }

    .btn-secondary {
      background: #fff;
      color: var(--primary);
      border: 2px solid var(--primary);
    }

    .btn-danger {
      background: var(--danger);
      color: #fff;
    }

    .btn-group {
      display: flex;
      gap: 15px;
      flex-wrap: wrap;
      justify-content: center;
      margin-top: 25px;
    }

    /* ===== Banners ===== */
    .banner {
      padding: 14px 18px;
      border-radius: 10px;
      margin: 20px 0;
      font-size: .95rem;
    }

    .banner.info {
      background: #eef7ff;
      border-left: 4px solid #3b82f6;
    }

    .banner.warn {
      background: #fff7e6;
      border-left: 4px solid #f59e0b;
    }

    .banner.error {
      background: #ffecec;
      border-left: 4px solid #ef4444;
    }

    /* ===== Modal ===== */
    .modal-overlay {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,.85);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 10000;
      backdrop-filter: blur(5px);
    }

    .modal-overlay.active {
      display: flex;
    }

    .modal-content {
      background: #fff;
      border-radius: 20px;
      max-width: 800px;
      width: 92%;
      max-height: 85vh;
      overflow: hidden;
      box-shadow: 0 20px 60px rgba(0,0,0,.3);
      animation: modalSlide .3s ease;
    }

    @keyframes modalSlide {
      from { transform: translateY(-30px); opacity: 0; }
      to { transform: translateY(0); opacity: 1; }
    }

    .modal-header {
      background: linear-gradient(135deg, var(--primary), var(--secondary));
      color: #fff;
      padding: 25px;
      position: relative;
    }

    .modal-close {
      position: absolute;
      right: 20px;
      top: 50%;
      transform: translateY(-50%);
      background: rgba(255,255,255,.2);
      border: none;
      color: #fff;
      width: 36px;
      height: 36px;
      border-radius: 50%;
      cursor: pointer;
      font-size: 1.3rem;
      transition: .2s;
    }

    .modal-close:hover {
      background: rgba(255,255,255,.3);
    }

    .modal-body {
      padding: 30px;
      overflow-y: auto;
      max-height: 60vh;
    }

    /* ===== Loading ===== */
    .loading-spinner {
      width: 40px;
      height: 40px;
      border: 4px solid #ddd;
      border-top-color: var(--primary);
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin: 20px auto;
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    /* ===== Responsive ===== */
    @media (max-width: 768px) {
      .app-header h1 { font-size: 2rem; }
      .upload-grid { grid-template-columns: 1fr; }
      .result-grid { grid-template-columns: repeat(auto-fit, minmax(180px, 1fr)); }
      .interpretation-grid { grid-template-columns: 1fr; }
    }
  </style>
</head>
<body>
  <header class="app-header">
    <h1>ğŸ–ï¸ PalmAI Pro Professional</h1>
    <p>ê°€ë” ì˜¤ë¥˜ê°€ ë‚  ìˆ˜ë„ ìˆëŠ” ì†ê¸ˆ ë¶„ì„ê¸° ^^ Â· ì¬ë¯¸ë¡œ ë´ ì£¼ì„¸ìš”~~</p>
  </header>

  <main class="main-container">
    <!-- Step Navigation -->
    <nav class="step-navigation">
      <div class="steps">
        <div class="step active" data-step="1">
          <div class="step-number">1</div>
          <div class="step-label">ì´ë¯¸ì§€ ì—…ë¡œë“œ</div>
        </div>
        <div class="step" data-step="2">
          <div class="step-number">2</div>
          <div class="step-label">ì „ì²˜ë¦¬</div>
        </div>
        <div class="step" data-step="3">
          <div class="step-number">3</div>
          <div class="step-label">ì‚¬ì£¼ ì…ë ¥</div>
        </div>
        <div class="step" data-step="4">
          <div class="step-number">4</div>
          <div class="step-label">AI ë¶„ì„</div>
        </div>
        <div class="step" data-step="5">
          <div class="step-number">5</div>
          <div class="step-label">ì „ë¬¸ê°€ ë¦¬í¬íŠ¸</div>
        </div>
      </div>
      <div class="progress-bar">
        <div class="progress-fill"></div>
      </div>
    </nav>

    <!-- Content Area -->
    <div class="content-area">
      <!-- Step 1: Upload -->
      <section class="step-content active" id="step1">
        <h2>ê³ í™”ì§ˆ ì†ë°”ë‹¥ ì´ë¯¸ì§€ ì—…ë¡œë“œ</h2>
        <div class="banner info">
          <strong>ğŸ“¸ ì´¬ì˜ ê°€ì´ë“œ:</strong> ë°ì€ ìì—°ê´‘ì—ì„œ ì†ë°”ë‹¥ì„ ì™„ì „íˆ í´ê³ , ì†ê¸ˆì„ ì´ ëª…í™•íˆ ë³´ì´ë„ë¡ ì´¬ì˜í•˜ì„¸ìš”.
          ìµœì†Œ 2048x2048 í”½ì…€ ì´ìƒì˜ ê³ í™”ì§ˆ ì´ë¯¸ì§€ë¥¼ ê¶Œì¥í•©ë‹ˆë‹¤.
        </div>

        <div class="upload-grid">
          <!-- Left Hand -->
          <label for="left-hand-input" class="upload-card">
            <input type="file" id="left-hand-input" accept="image/*" style="display:none"/>
            <div class="upload-icon">ğŸ¤š</div>
            <h3>ì™¼ì† (ì„ ì²œì  íŠ¹ì„±)</h3>
            <p>ì ì¬ë ¥, íƒ€ê³ ë‚œ ì„±í–¥ ë¶„ì„</p>
            <img class="upload-preview" id="left-preview" alt="ì™¼ì† ë¯¸ë¦¬ë³´ê¸°"/>
            <div class="quality-badge" id="left-quality"></div>
          </label>

          <!-- Right Hand -->
          <label for="right-hand-input" class="upload-card">
            <input type="file" id="right-hand-input" accept="image/*" style="display:none"/>
            <div class="upload-icon">ğŸ–ï¸</div>
            <h3>ì˜¤ë¥¸ì† (í›„ì²œì  ë°œí˜„)</h3>
            <p>í˜„ì¬ ìƒíƒœ, ë…¸ë ¥ì˜ ê²°ê³¼ ë¶„ì„</p>
            <img class="upload-preview" id="right-preview" alt="ì˜¤ë¥¸ì† ë¯¸ë¦¬ë³´ê¸°"/>
            <div class="quality-badge" id="right-quality"></div>
          </label>
        </div>

        <div class="btn-group">
          <button class="btn btn-primary" onclick="nextStep()">ë‹¤ìŒ ë‹¨ê³„: ì´ë¯¸ì§€ ì „ì²˜ë¦¬</button>
        </div>
      </section>

      <!-- Step 2: Preprocessing -->
      <section class="step-content" id="step2">
        <h2>ì´ë¯¸ì§€ ì „ì²˜ë¦¬ ë° í’ˆì§ˆ ê²€ì¦</h2>
        <canvas id="palm-canvas" width="800" height="600"></canvas>
        
        <div class="expert-panel">
          <h3>ğŸ” ì „ì²˜ë¦¬ ìƒíƒœ</h3>
          <ul class="feature-list">
            <li>
              <span class="feature-label">ì´ë¯¸ì§€ í•´ìƒë„</span>
              <span class="feature-value" id="resolution-value">ë¶„ì„ ì¤‘...</span>
            </li>
            <li>
              <span class="feature-label">ëª…ì•” ëŒ€ë¹„</span>
              <span class="feature-value" id="contrast-value">ë¶„ì„ ì¤‘...</span>
            </li>
            <li>
              <span class="feature-label">ì„ ëª…ë„</span>
              <span class="feature-value" id="sharpness-value">ë¶„ì„ ì¤‘...</span>
            </li>
            <li>
              <span class="feature-label">ë…¸ì´ì¦ˆ ìˆ˜ì¤€</span>
              <span class="feature-value" id="noise-value">ë¶„ì„ ì¤‘...</span>
            </li>
          </ul>
        </div>

        <div class="btn-group">
          <button class="btn btn-secondary" onclick="previousStep()">ì´ì „</button>
          <button class="btn btn-primary" onclick="nextStep()">ë‹¤ìŒ ë‹¨ê³„: ì‚¬ì£¼ ì •ë³´</button>
        </div>
      </section>

      <!-- Step 3: Saju Input -->
      <section class="step-content" id="step3">
        <h2>ì‚¬ì£¼ ì •ë³´ ì…ë ¥ (ì„ íƒì‚¬í•­)</h2>
        <div class="banner info">
          <strong>ğŸŒŸ ì •í™•ë„ í–¥ìƒ:</strong> ì‚¬ì£¼ ì •ë³´ë¥¼ ì…ë ¥í•˜ë©´ ì†ê¸ˆ ë¶„ì„ê³¼ í†µí•©í•˜ì—¬ ë”ìš± ì •ë°€í•œ í•´ì„ì„ ì œê³µí•©ë‹ˆë‹¤.
        </div>

        <form class="saju-form" id="saju-form" novalidate>
          <div class="form-group">
            <label for="birth-year">ìƒë…„</label>
            <input type="number" class="form-control" id="birth-year" 
                   placeholder="ì˜ˆ: 1991" min="1900" max="2100"/>
            <div class="hint">ì–‘ë ¥ ê¸°ì¤€</div>
          </div>
          <div class="form-group">
            <label for="birth-month">ìƒì›”</label>
            <input type="number" class="form-control" id="birth-month" 
                   placeholder="1-12" min="1" max="12"/>
          </div>
          <div class="form-group">
            <label for="birth-day">ìƒì¼</label>
            <input type="number" class="form-control" id="birth-day" 
                   placeholder="1-31" min="1" max="31"/>
          </div>
          <div class="form-group">
            <label for="birth-hour">ìƒì‹œ</label>
            <input type="number" class="form-control" id="birth-hour" 
                   placeholder="0-23" min="0" max="23"/>
            <div class="hint">24ì‹œê°„ í˜•ì‹</div>
          </div>
          <div class="form-group">
            <label for="gender">ì„±ë³„</label>
            <select class="form-control" id="gender">
              <option value="">ì„ íƒ</option>
              <option value="male">ë‚¨ì„±</option>
              <option value="female">ì—¬ì„±</option>
            </select>
          </div>
          <div class="form-group">
            <label>
              <input type="checkbox" id="lunar-calendar"/> ìŒë ¥
            </label>
          </div>
        </form>

        <div class="btn-group">
          <button class="btn btn-secondary" onclick="previousStep()">ì´ì „</button>
          <button class="btn btn-primary" onclick="nextStep()">ë‹¤ìŒ ë‹¨ê³„: AI ë¶„ì„ ì‹œì‘</button>
        </div>
      </section>

      <!-- Step 4: Analysis -->
      <section class="step-content" id="step4">
        <h2>ë”¥ëŸ¬ë‹ ê¸°ë°˜ ì „ë¬¸ê°€ ë¶„ì„ ì§„í–‰</h2>
        <div class="analysis-progress">
          <div class="analysis-step" id="preprocessing">
            <span>ğŸ“¸ ì´ë¯¸ì§€ ì „ì²˜ë¦¬ (ë…¸ì´ì¦ˆ ì œê±°, ìƒ‰ìƒ ë³´ì •)</span>
            <span class="progress-percentage">0%</span>
          </div>
          <div class="analysis-step" id="segmentation">
            <span>ğŸ” CNN ê¸°ë°˜ ì†ê¸ˆì„  ì„¸ê·¸ë©˜í…Œì´ì…˜</span>
            <span class="progress-percentage">0%</span>
          </div>
          <div class="analysis-step" id="feature-extraction">
            <span>ğŸ“Š ì£¼ì„ /ë³´ì¡°ì„  íŠ¹ì§• ì¶”ì¶œ (ê¸¸ì´, ê¹Šì´, ë¶„ê¸°)</span>
            <span class="progress-percentage">0%</span>
          </div>
          <div class="analysis-step" id="pattern-matching">
            <span>ğŸ§¬ ì „ë¬¸ê°€ DB íŒ¨í„´ ë§¤ì¹­</span>
            <span class="progress-percentage">0%</span>
          </div>
          <div class="analysis-step" id="report-generation">
            <span>ğŸ“ ì¢…í•© ë¦¬í¬íŠ¸ ìƒì„±</span>
            <span class="progress-percentage">0%</span>
          </div>
        </div>

        <div class="btn-group">
          <button class="btn btn-secondary" onclick="previousStep()">ì´ì „</button>
          <button class="btn btn-primary" onclick="startProfessionalAnalysis()">ì „ë¬¸ê°€ ë¶„ì„ ì‹œì‘</button>
        </div>
      </section>

      <!-- Step 5: Professional Report -->
      <section class="step-content" id="step5">
        <h2>ì „ë¬¸ê°€ ìˆ˜ì¤€ ì¢…í•© ë¶„ì„ ë¦¬í¬íŠ¸</h2>
        
        <div id="global-banners"></div>

        <!-- Score Overview -->
        <div class="result-grid" id="result-grid"></div>

        <!-- Main Lines Analysis -->
        <div class="expert-panel">
          <h3>ğŸ“‹ ì£¼ìš” ì†ê¸ˆì„  ìƒì„¸ ë¶„ì„</h3>
          <div id="main-lines-analysis"></div>
        </div>

        <!-- Auxiliary Lines Analysis -->
        <div class="expert-panel">
          <h3>ğŸ“ ë³´ì¡°ì„  ë° íŠ¹ìˆ˜ ë¬¸ì–‘ ë¶„ì„</h3>
          <div id="auxiliary-lines-analysis"></div>
        </div>

        <!-- Professional Interpretation -->
        <div class="interpretation-section">
          <h3>ğŸ¯ ì „ë¬¸ê°€ ì¢…í•© í•´ì„</h3>
          <div class="interpretation-grid" id="interpretation-grid"></div>
        </div>

        <!-- Life Phase Analysis -->
        <div class="expert-panel">
          <h3>ğŸ“… ìƒì•  ì£¼ê¸°ë³„ ì˜ˆì¸¡</h3>
          <div id="life-phase-analysis"></div>
        </div>

        <div class="btn-group">
          <button class="btn btn-secondary" onclick="exportProfessionalReport()">ğŸ“Š ì „ë¬¸ ë¦¬í¬íŠ¸ ë‹¤ìš´ë¡œë“œ</button>
          <button class="btn btn-danger" onclick="resetAnalysis()">ğŸ”„ ìƒˆ ë¶„ì„ ì‹œì‘</button>
        </div>
      </section>
    </div>
  </main>

  <!-- Modal -->
  <div class="modal-overlay" id="detail-modal">
    <div class="modal-content">
      <div class="modal-header">
        <h2 id="modal-title">ìƒì„¸ ë¶„ì„</h2>
        <button class="modal-close" onclick="closeModal()">âœ•</button>
      </div>
      <div class="modal-body" id="modal-body"></div>
    </div>
  </div>

  <script>
    'use strict';

    // ===== Professional Palm Reading Database =====
    const PALM_LINES_DB = {
      // ì£¼ì„  (Major Lines)
      lifeLine: {
        name: 'ìƒëª…ì„ ',
        aspects: ['length', 'depth', 'curve', 'breaks', 'branches', 'islands'],
        interpretation: {
          long: 'ê°•ì¸í•œ ìƒëª…ë ¥ê³¼ í™œë ¥, ì¥ìˆ˜ì˜ ê°€ëŠ¥ì„±',
          deep: 'ê±´ê°•í•˜ê³  ì•ˆì •ì ì¸ ì²´ì§ˆ',
          curved: 'ë”°ëœ»í•˜ê³  ê´€ëŒ€í•œ ì„±ê²©',
          straight: 'ì‹ ì¤‘í•˜ê³  ì¡°ì‹¬ìŠ¤ëŸ¬ìš´ ì„±í–¥',
          broken: 'ì¸ìƒì˜ ì „í™˜ì ì´ë‚˜ ê±´ê°•ìƒ ì£¼ì˜ ì‹œê¸°',
          island: 'ì¼ì‹œì  ê±´ê°• ë¬¸ì œë‚˜ ìŠ¤íŠ¸ë ˆìŠ¤ ì‹œê¸°',
          branches_up: 'ê¸ì •ì  ì—ë„ˆì§€ì™€ ì„±ì¥',
          branches_down: 'ì—ë„ˆì§€ ì†Œëª¨ë‚˜ í”¼ë¡œ ì‹œê¸°'
        }
      },
      headLine: {
        name: 'ë‘ë‡Œì„ ',
        aspects: ['length', 'slope', 'clarity', 'fork', 'islands', 'dots'],
        interpretation: {
          long: 'ê¹Šì€ ì‚¬ê³ ë ¥ê³¼ ì§‘ì¤‘ë ¥',
          short: 'ì‹¤ìš©ì ì´ê³  ì§ì„ ì ì¸ ì‚¬ê³ ',
          straight: 'ë…¼ë¦¬ì ì´ê³  ë¶„ì„ì ì¸ ì‚¬ê³ ',
          curved: 'ì°½ì˜ì ì´ê³  ìƒìƒë ¥ì´ í’ë¶€',
          forked: 'ë‹¤ì¬ë‹¤ëŠ¥í•œ ì§€ì  ëŠ¥ë ¥',
          clear: 'ëª…í™•í•œ íŒë‹¨ë ¥ê³¼ ê²°ë‹¨ë ¥',
          wavy: 'ë³€í™”ë¬´ìŒí•œ ì‚¬ê³  íŒ¨í„´'
        }
      },
      heartLine: {
        name: 'ê°ì •ì„ ',
        aspects: ['length', 'curve', 'branches', 'chains', 'depth'],
        interpretation: {
          long: 'ê¹Šê³  ì§€ì†ì ì¸ ê°ì • í‘œí˜„',
          curved: 'ì—´ì •ì ì´ê³  í‘œí˜„ë ¥ì´ í’ë¶€',
          straight: 'ì´ì„±ì ì´ê³  ì ˆì œëœ ê°ì • í‘œí˜„',
          branched: 'ë‹¤ì–‘í•œ ê°ì •ì  ê²½í—˜',
          chained: 'ê°ì •ì  í˜¼ë€ì´ë‚˜ ë³µì¡í•œ ê´€ê³„',
          deep: 'ê°•ë ¬í•œ ê°ì •ê³¼ ê¹Šì€ ì• ì •'
        }
      },
      fateLine: {
        name: 'ìš´ëª…ì„ ',
        aspects: ['presence', 'length', 'direction', 'breaks', 'strength'],
        interpretation: {
          strong: 'ëª…í™•í•œ ì¸ìƒ ëª©í‘œì™€ ê°•í•œ ì˜ì§€',
          weak: 'ìœ ì—°í•œ ì¸ìƒ ê²½ë¡œ',
          absent: 'ììœ ë¡œìš´ ì˜í˜¼, ë…ë¦½ì  ì„±í–¥',
          broken: 'ê²½ë ¥ ë³€í™”ë‚˜ ì „í™˜ì ',
          double: 'ë‹¤ì¤‘ ê²½ë ¥ì´ë‚˜ ë¶€ì—… ê°€ëŠ¥ì„±'
        }
      },
      
      // ë³´ì¡°ì„  (Minor Lines)
      sunLine: {
        name: 'íƒœì–‘ì„ ',
        aspects: ['presence', 'length', 'clarity'],
        interpretation: {
          present: 'ì„±ê³µê³¼ ëª…ì˜ˆ, ì°½ì˜ì  ì¬ëŠ¥',
          long: 'ì§€ì†ì ì¸ ì„±ê³µê³¼ ì¸ì •',
          multiple: 'ë‹¤ë°©ë©´ì˜ ì¬ëŠ¥ê³¼ ì„±ê³µ ê°€ëŠ¥ì„±'
        }
      },
      mercuryLine: {
        name: 'ìˆ˜ì„±ì„  (ê±´ê°•ì„ )',
        aspects: ['presence', 'clarity', 'breaks'],
        interpretation: {
          absent: 'ê±´ê°•í•œ ì²´ì§ˆ (ì—†ëŠ” ê²ƒì´ ì¢‹ìŒ)',
          clear: 'ì‚¬ì—… ìˆ˜ì™„ê³¼ ì»¤ë®¤ë‹ˆì¼€ì´ì…˜ ëŠ¥ë ¥',
          wavy: 'ì†Œí™”ê¸° ê³„í†µ ì£¼ì˜ í•„ìš”'
        }
      },
      marriageLines: {
        name: 'ê²°í˜¼ì„ ',
        aspects: ['count', 'length', 'depth', 'fork'],
        interpretation: {
          single_deep: 'í•œ ë²ˆì˜ ê¹Šì€ ì¸ì—°',
          multiple: 'ì—¬ëŸ¬ ë²ˆì˜ ì¤‘ìš”í•œ ê´€ê³„',
          forked: 'ê´€ê³„ì˜ ë³€í™”ë‚˜ ë„ì „',
          curved_up: 'í–‰ë³µí•œ ê´€ê³„',
          curved_down: 'ê´€ê³„ì˜ ì–´ë ¤ì›€'
        }
      },
      childrenLines: {
        name: 'ìë…€ì„ ',
        aspects: ['count', 'depth'],
        interpretation: {
          deep: 'ê±´ê°•í•œ ìë…€',
          faint: 'ìë…€ì™€ì˜ ì—°ì´ ì•½í•¨',
          multiple: 'ì—¬ëŸ¬ ìë…€ ê°€ëŠ¥ì„±'
        }
      },
      intuitionLine: {
        name: 'ì§ê´€ì„ ',
        aspects: ['presence', 'clarity'],
        interpretation: {
          present: 'ê°•í•œ ì§ê´€ë ¥ê³¼ ì˜ì  ê°ê°',
          clear: 'ë›°ì–´ë‚œ í†µì°°ë ¥'
        }
      },
      
      // íŠ¹ìˆ˜ ë¬¸ì–‘ (Special Marks)
      specialMarks: {
        star: {
          name: 'ë³„',
          interpretation: 'íŠ¹ë³„í•œ ì¬ëŠ¥ì´ë‚˜ í–‰ìš´ì˜ ì‹œê¸°'
        },
        cross: {
          name: 'ì‹­ì',
          interpretation: 'ë„ì „ì´ë‚˜ ì‹œë ¨, ë•Œë¡œëŠ” ë³´í˜¸ì˜ í‘œì‹œ'
        },
        square: {
          name: 'ì‚¬ê°í˜•',
          interpretation: 'ë³´í˜¸ì™€ ì•ˆì •ì˜ í‘œì‹œ'
        },
        triangle: {
          name: 'ì‚¼ê°í˜•',
          interpretation: 'ì§€ì  ëŠ¥ë ¥ê³¼ ì„±ê³µ'
        },
        grille: {
          name: 'ê²©ì',
          interpretation: 'ì—ë„ˆì§€ ë¶„ì‚°ì´ë‚˜ í˜¼ë€'
        },
        island: {
          name: 'ì„¬',
          interpretation: 'ì¼ì‹œì  ì–´ë ¤ì›€ì´ë‚˜ ì¥ì• '
        },
        dot: {
          name: 'ì ',
          interpretation: 'ì¼ì‹œì  ë¬¸ì œë‚˜ ì£¼ì˜ì '
        }
      }
    };

    // ===== Mount Areas Database =====
    const MOUNT_AREAS = {
      jupiter: {
        name: 'ëª©ì„±êµ¬',
        location: 'ê²€ì§€ ì•„ë˜',
        traits: 'ë¦¬ë”ì‹­, ì•¼ë§, ìì‹ ê°',
        interpretation: {
          developed: 'ê°•í•œ ë¦¬ë”ì‹­ê³¼ ì•¼ë§',
          flat: 'ê²¸ì†í•˜ê³  í˜‘ì¡°ì ',
          overdeveloped: 'ê³¼ë„í•œ ìë§Œì‹¬ ì£¼ì˜'
        }
      },
      saturn: {
        name: 'í† ì„±êµ¬',
        location: 'ì¤‘ì§€ ì•„ë˜',
        traits: 'ì±…ì„ê°, ì§„ì§€í•¨, ì—°êµ¬ì‹¬',
        interpretation: {
          developed: 'ì‹ ì¤‘í•˜ê³  ì±…ì„ê° ìˆìŒ',
          flat: 'ê²½ì†”í•  ìˆ˜ ìˆìŒ',
          overdeveloped: 'ìš°ìš¸í•˜ê±°ë‚˜ ë¹„ê´€ì  ì„±í–¥'
        }
      },
      sun: {
        name: 'íƒœì–‘êµ¬',
        location: 'ì•½ì§€ ì•„ë˜',
        traits: 'ì°½ì˜ì„±, ì˜ˆìˆ ì„±, ëª…ì˜ˆ',
        interpretation: {
          developed: 'ì˜ˆìˆ ì  ì¬ëŠ¥ê³¼ ì°½ì˜ì„±',
          flat: 'ì˜ˆìˆ ì  ê´€ì‹¬ ë¶€ì¡±',
          overdeveloped: 'í—ˆì˜ì‹¬ ì£¼ì˜'
        }
      },
      mercury: {
        name: 'ìˆ˜ì„±êµ¬',
        location: 'ìƒˆë¼ì†ê°€ë½ ì•„ë˜',
        traits: 'ì»¤ë®¤ë‹ˆì¼€ì´ì…˜, ì‚¬ì—… ìˆ˜ì™„',
        interpretation: {
          developed: 'ë›°ì–´ë‚œ ì†Œí†µ ëŠ¥ë ¥',
          flat: 'ì†Œí†µì— ì–´ë ¤ì›€',
          overdeveloped: 'ê³¼ë„í•œ ë§ìˆ˜'
        }
      },
      mars_positive: {
        name: 'ì–‘ í™”ì„±êµ¬',
        location: 'ìƒëª…ì„  ì‹œì‘ ë¶€ë¶„',
        traits: 'ìš©ê¸°, í™œë ¥, ë„ì „ì •ì‹ '
      },
      mars_negative: {
        name: 'ìŒ í™”ì„±êµ¬',
        location: 'ì†ë°”ë‹¥ ì™¸ì¸¡ ì¤‘ê°„',
        traits: 'ì¸ë‚´, ì €í•­ë ¥'
      },
      venus: {
        name: 'ê¸ˆì„±êµ¬',
        location: 'ì—„ì§€ ì•„ë˜',
        traits: 'ì‚¬ë‘, ë¯¸ì  ê°ê°, ê°ì„±',
        interpretation: {
          developed: 'ë”°ëœ»í•˜ê³  ì• ì •ì´ í’ë¶€',
          flat: 'ê°ì • í‘œí˜„ì— ì„œíˆ¼',
          overdeveloped: 'ê³¼ë„í•œ ìš•êµ¬'
        }
      },
      luna: {
        name: 'ì›”êµ¬',
        location: 'ì†ë°”ë‹¥ í•˜ë‹¨ ì™¸ì¸¡',
        traits: 'ìƒìƒë ¥, ì§ê´€, ì°½ì˜ì„±',
        interpretation: {
          developed: 'í’ë¶€í•œ ìƒìƒë ¥',
          flat: 'í˜„ì‹¤ì  ì„±í–¥',
          overdeveloped: 'ê³¼ë„í•œ í™˜ìƒ'
        }
      }
    };

    // ===== Application State =====
    const AppState = {
      currentStep: 1,
      palmImages: {
        left: null,
        right: null,
        quality: { left: null, right: null }
      },
      preprocessedData: {
        left: null,
        right: null
      },
      sajuData: {
        year: null,
        month: null,
        day: null,
        hour: null,
        gender: null,
        isLunar: false
      },
      analysisResults: null,
      extractedFeatures: {
        left: null,
        right: null
      }
    };

    // ===== Image Processing Functions =====
    
    /**
     * Advanced image quality evaluation using multiple metrics
     */
    async function evaluateImageQuality(dataUrl) {
      return new Promise((resolve) => {
        const img = new Image();
        img.onload = () => {
          const canvas = document.createElement('canvas');
          const ctx = canvas.getContext('2d');
          canvas.width = canvas.height = 512;
          ctx.drawImage(img, 0, 0, 512, 512);
          
          const imageData = ctx.getImageData(0, 0, 512, 512);
          const data = imageData.data;
          
          // Calculate multiple quality metrics
          let brightness = 0, contrast = 0, sharpness = 0;
          let min = 255, max = 0;
          let edges = 0;
          
          for (let i = 0; i < data.length; i += 4) {
            const gray = 0.299 * data[i] + 0.587 * data[i+1] + 0.114 * data[i+2];
            brightness += gray;
            min = Math.min(min, gray);
            max = Math.max(max, gray);
            
            // Simple edge detection for sharpness
            if (i > 512 * 4) {
              const diff = Math.abs(gray - (0.299 * data[i-512*4] + 0.587 * data[i-512*4+1] + 0.114 * data[i-512*4+2]));
              if (diff > 30) edges++;
            }
          }
          
          brightness = brightness / (512 * 512);
          contrast = (max - min) / 255;
          sharpness = edges / (512 * 512) * 100;
          
          // Calculate overall quality score
          const brightnessScore = Math.abs(brightness - 128) < 50 ? 35 : 15;
          const contrastScore = contrast > 0.4 ? 35 : 20;
          const sharpnessScore = sharpness > 5 ? 30 : 15;
          
          const overallScore = Math.round(brightnessScore + contrastScore + sharpnessScore);
          
          resolve({
            score: Math.max(30, Math.min(95, overallScore)),
            brightness: Math.round(brightness),
            contrast: Math.round(contrast * 100),
            sharpness: Math.round(sharpness),
            resolution: `${img.width}x${img.height}`
          });
        };
        img.src = dataUrl;
      });
    }

    /**
     * Image preprocessing - noise reduction, contrast enhancement
     */
    async function preprocessImage(dataUrl) {
      return new Promise((resolve) => {
        const img = new Image();
        img.onload = () => {
          const canvas = document.getElementById('palm-canvas');
          const ctx = canvas.getContext('2d');
          
          // Resize to standard dimensions
          canvas.width = 800;
          canvas.height = 600;
          ctx.drawImage(img, 0, 0, 800, 600);
          
          // Apply contrast enhancement
          const imageData = ctx.getImageData(0, 0, 800, 600);
          const data = imageData.data;
          
          // Histogram equalization for better contrast
          const histogram = new Array(256).fill(0);
          for (let i = 0; i < data.length; i += 4) {
            const gray = Math.round(0.299 * data[i] + 0.587 * data[i+1] + 0.114 * data[i+2]);
            histogram[gray]++;
          }
          
          // Cumulative distribution
          const cdf = histogram.slice();
          for (let i = 1; i < 256; i++) {
            cdf[i] += cdf[i-1];
          }
          
          // Normalize and apply
          const pixels = 800 * 600;
          for (let i = 0; i < data.length; i += 4) {
            const gray = Math.round(0.299 * data[i] + 0.587 * data[i+1] + 0.114 * data[i+2]);
            const newGray = Math.round((cdf[gray] / pixels) * 255);
            const scale = newGray / (gray || 1);
            
            data[i] = Math.min(255, data[i] * scale);
            data[i+1] = Math.min(255, data[i+1] * scale);
            data[i+2] = Math.min(255, data[i+2] * scale);
          }
          
          ctx.putImageData(imageData, 0, 0);
          
          resolve({
            processed: canvas.toDataURL(),
            width: 800,
            height: 600
          });
        };
        img.src = dataUrl;
      });
    }

    /**
     * Simulated CNN-based palm line segmentation
     * In production, this would use TensorFlow.js or similar
     */
    function segmentPalmLines(preprocessedData) {
      // Simulate segmentation results
      const lines = {
        lifeLine: {
          detected: true,
          confidence: 0.92,
          points: generateLinePoints('curve', 50),
          thickness: Math.random() * 3 + 1,
          depth: Math.random() * 0.4 + 0.6
        },
        headLine: {
          detected: true,
          confidence: 0.89,
          points: generateLinePoints('straight', 40),
          thickness: Math.random() * 2.5 + 1,
          depth: Math.random() * 0.3 + 0.5
        },
        heartLine: {
          detected: true,
          confidence: 0.91,
          points: generateLinePoints('curve', 45),
          thickness: Math.random() * 2.8 + 1,
          depth: Math.random() * 0.35 + 0.55
        },
        fateLine: {
          detected: Math.random() > 0.3,
          confidence: Math.random() * 0.3 + 0.6,
          points: generateLinePoints('straight', 35),
          thickness: Math.random() * 2 + 0.5,
          depth: Math.random() * 0.25 + 0.4
        }
      };
      
      return lines;
    }

    function generateLinePoints(type, count) {
      const points = [];
      for (let i = 0; i < count; i++) {
        const t = i / count;
        let x, y;
        
        if (type === 'curve') {
          x = t * 600 + 100;
          y = 300 + Math.sin(t * Math.PI) * 100 + (Math.random() - 0.5) * 20;
        } else {
          x = t * 600 + 100;
          y = 300 + t * 50 + (Math.random() - 0.5) * 20;
        }
        
        points.push({ x, y });
      }
      return points;
    }

    /**
     * Extract detailed features from segmented lines
     */
    function extractDetailedFeatures(segmentedLines) {
      const features = {};
      
      Object.keys(segmentedLines).forEach(lineKey => {
        const line = segmentedLines[lineKey];
        if (!line.detected) return;
        
        const points = line.points;
        const length = calculateLineLength(points);
        const curvature = calculateCurvature(points);
        const breaks = detectBreaks(points);
        const branches = detectBranches(points);
        const islands = detectIslands(points);
        
        features[lineKey] = {
          length: length,
          depth: line.depth,
          thickness: line.thickness,
          curvature: curvature,
          breaks: breaks,
          branches: branches,
          islands: islands,
          confidence: line.confidence
        };
      });
      
      // Extract mount features
      features.mounts = extractMountFeatures();
      
      // Extract special marks
      features.specialMarks = detectSpecialMarks();
      
      return features;
    }

    function calculateLineLength(points) {
      let length = 0;
      for (let i = 1; i < points.length; i++) {
        const dx = points[i].x - points[i-1].x;
        const dy = points[i].y - points[i-1].y;
        length += Math.sqrt(dx * dx + dy * dy);
      }
      return length;
    }

    function calculateCurvature(points) {
      if (points.length < 3) return 0;
      
      let totalCurvature = 0;
      for (let i = 1; i < points.length - 1; i++) {
        const v1 = { 
          x: points[i].x - points[i-1].x,
          y: points[i].y - points[i-1].y
        };
        const v2 = {
          x: points[i+1].x - points[i].x,
          y: points[i+1].y - points[i].y
        };
        
        const angle = Math.atan2(v2.y, v2.x) - Math.atan2(v1.y, v1.x);
        totalCurvature += Math.abs(angle);
      }
      
      return totalCurvature / (points.length - 2);
    }

    function detectBreaks(points) {
      // Simulate break detection
      return Math.random() > 0.7 ? Math.floor(Math.random() * 3) : 0;
    }

    function detectBranches(points) {
      // Simulate branch detection
      return Math.random() > 0.5 ? Math.floor(Math.random() * 4) + 1 : 0;
    }

    function detectIslands(points) {
      // Simulate island detection
      return Math.random() > 0.8 ? Math.floor(Math.random() * 2) + 1 : 0;
    }

    function extractMountFeatures() {
      const mounts = {};
      Object.keys(MOUNT_AREAS).forEach(mount => {
        mounts[mount] = {
          development: Math.random() * 0.5 + 0.5, // 0.5-1.0
          firmness: Math.random() * 0.4 + 0.6,
          marks: Math.random() > 0.7 ? ['star'] : []
        };
      });
      return mounts;
    }

    function detectSpecialMarks() {
      const marks = [];
      const markTypes = Object.keys(PALM_LINES_DB.specialMarks);
      
      const markCount = Math.floor(Math.random() * 4) + 1;
      for (let i = 0; i < markCount; i++) {
        marks.push({
          type: markTypes[Math.floor(Math.random() * markTypes.length)],
          location: ['ìƒëª…ì„ ', 'ë‘ë‡Œì„ ', 'ê°ì •ì„ ', 'ìš´ëª…ì„ '][Math.floor(Math.random() * 4)],
          significance: Math.random() * 0.4 + 0.6
        });
      }
      
      return marks;
    }

    /**
     * Generate professional interpretation based on features
     */
    function generateProfessionalInterpretation(features) {
      const interpretations = {};
      
      // Analyze main lines
      Object.keys(PALM_LINES_DB).forEach(lineKey => {
        if (lineKey === 'specialMarks') return;
        
        const lineFeatures = features[lineKey];
        if (!lineFeatures) return;
        
        const lineDB = PALM_LINES_DB[lineKey];
        const interpretation = [];
        
        // Length interpretation
        if (lineFeatures.length > 400) {
          interpretation.push(lineDB.interpretation.long || 'ê¸´ ì„ ');
        } else if (lineFeatures.length < 200) {
          interpretation.push(lineDB.interpretation.short || 'ì§§ì€ ì„ ');
        }
        
        // Depth interpretation
        if (lineFeatures.depth > 0.7) {
          interpretation.push(lineDB.interpretation.deep || 'ê¹Šì€ ì„ ');
        }
        
        // Curvature interpretation
        if (lineFeatures.curvature > 0.5) {
          interpretation.push(lineDB.interpretation.curved || 'ê³¡ì„ ');
        } else {
          interpretation.push(lineDB.interpretation.straight || 'ì§ì„ ');
        }
        
        // Breaks and islands
        if (lineFeatures.breaks > 0) {
          interpretation.push(lineDB.interpretation.broken || 'ë‹¨ì ˆ ìˆìŒ');
        }
        if (lineFeatures.islands > 0) {
          interpretation.push(lineDB.interpretation.island || 'ì„¬ ë¬¸ì–‘');
        }
        
        interpretations[lineKey] = {
          name: lineDB.name,
          features: lineFeatures,
          interpretation: interpretation,
          confidence: lineFeatures.confidence
        };
      });
      
      return interpretations;
    }

    /**
     * Calculate domain scores based on extracted features
     */
    function calculateDomainScores(leftFeatures, rightFeatures) {
      const domains = {
        career: calculateCareerScore(leftFeatures, rightFeatures),
        wealth: calculateWealthScore(leftFeatures, rightFeatures),
        love: calculateLoveScore(leftFeatures, rightFeatures),
        health: calculateHealthScore(leftFeatures, rightFeatures),
        personality: calculatePersonalityScore(leftFeatures, rightFeatures)
      };
      
      return domains;
    }

    function calculateCareerScore(left, right) {
      let score = 50;
      
      // Fate line contributes most to career
      if (right?.fateLine) {
        score += right.fateLine.depth * 20;
        score += right.fateLine.length > 300 ? 15 : 5;
      }
      
      // Head line affects career decisions
      if (right?.headLine) {
        score += right.headLine.clarity * 10;
      }
      
      // Jupiter mount for ambition
      if (right?.mounts?.jupiter) {
        score += right.mounts.jupiter.development * 10;
      }
      
      return Math.min(100, Math.round(score));
    }

    function calculateWealthScore(left, right) {
      let score = 50;
      
      // Sun line indicates success and wealth
      if (right?.sunLine) {
        score += 20;
      }
      
      // Mercury mount for business acumen
      if (right?.mounts?.mercury) {
        score += right.mounts.mercury.development * 15;
      }
      
      // Special marks
      const specialMarks = right?.specialMarks || [];
      specialMarks.forEach(mark => {
        if (mark.type === 'star' || mark.type === 'triangle') {
          score += 10;
        }
      });
      
      return Math.min(100, Math.round(score));
    }

    function calculateLoveScore(left, right) {
      let score = 50;
      
      // Heart line is primary for love
      const heartLine = right?.heartLine || left?.heartLine;
      if (heartLine) {
        score += heartLine.depth * 15;
        score += heartLine.branches > 2 ? 10 : 5;
      }
      
      // Venus mount for love and passion
      const venus = right?.mounts?.venus || left?.mounts?.venus;
      if (venus) {
        score += venus.development * 20;
      }
      
      return Math.min(100, Math.round(score));
    }

    function calculateHealthScore(left, right) {
      let score = 70;
      
      // Life line for vitality
      const lifeLine = left?.lifeLine || right?.lifeLine;
      if (lifeLine) {
        score += lifeLine.depth * 10;
        score -= lifeLine.breaks * 10;
        score -= lifeLine.islands * 5;
      }
      
      // Mercury line (health line) - absence is actually good
      if (!right?.mercuryLine && !left?.mercuryLine) {
        score += 10;
      }
      
      return Math.min(100, Math.max(30, Math.round(score)));
    }

    function calculatePersonalityScore(left, right) {
      let score = 60;
      
      // Head line for thinking patterns
      const headLine = right?.headLine || left?.headLine;
      if (headLine) {
        score += headLine.curvature > 0.5 ? 10 : 5; // Creative vs logical
      }
      
      // Mount development
      const mounts = right?.mounts || left?.mounts;
      if (mounts) {
        // Balanced mount development indicates balanced personality
        const developments = Object.values(mounts).map(m => m.development);
        const variance = calculateVariance(developments);
        score += (1 - variance) * 20; // Less variance = more balanced
      }
      
      return Math.min(100, Math.round(score));
    }

    function calculateVariance(values) {
      const mean = values.reduce((a, b) => a + b, 0) / values.length;
      const variance = values.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / values.length;
      return Math.min(1, variance);
    }

    /**
     * Generate life phase predictions based on palm analysis
     */
    function generateLifePhasePredictions(features) {
      const phases = [
        {
          age: '20-30ì„¸',
          prediction: 'ì„±ì¥ê³¼ íƒìƒ‰ì˜ ì‹œê¸°',
          details: 'ê²½ë ¥ ê¸°ë°˜ êµ¬ì¶•, ë‹¤ì–‘í•œ ê²½í—˜ ì¶•ì  ê¶Œì¥'
        },
        {
          age: '30-40ì„¸',
          prediction: 'ì•ˆì •ê³¼ ë°œì „ì˜ ì‹œê¸°',
          details: 'ì „ë¬¸ì„± í™•ë¦½, ê°€ì • ì•ˆì •í™” ì¤‘ìš”'
        },
        {
          age: '40-50ì„¸',
          prediction: 'ì„±ìˆ™ê³¼ ìˆ˜í™•ì˜ ì‹œê¸°',
          details: 'ì¶•ì ëœ ê²½í—˜ í™œìš©, ë¦¬ë”ì‹­ ë°œíœ˜'
        },
        {
          age: '50-60ì„¸',
          prediction: 'ì§€í˜œì™€ ë©˜í† ë§ì˜ ì‹œê¸°',
          details: 'í›„ë°° ì–‘ì„±, ì‚¬íšŒ ê¸°ì—¬ í™•ëŒ€'
        },
        {
          age: '60ì„¸ ì´ìƒ',
          prediction: 'ì„±ì°°ê³¼ ìœ ì‚°ì˜ ì‹œê¸°',
          details: 'ì¸ìƒ ì •ë¦¬, ì§€í˜œ ì „ìˆ˜'
        }
      ];
      
      // Customize based on palm features
      if (features.fateLine && features.fateLine.length > 400) {
        phases[1].details += ', ê²½ë ¥ ìƒìŠ¹ ê°€ëŠ¥ì„± ë†’ìŒ';
      }
      
      if (features.lifeLine && features.lifeLine.depth > 0.7) {
        phases.forEach(phase => {
          phase.health = 'ê±´ê°• ìƒíƒœ ì–‘í˜¸ ì˜ˆìƒ';
        });
      }
      
      return phases;
    }

    // ===== UI Functions =====
    
    function updateStepUI() {
      // Update step indicators
      document.querySelectorAll('.step').forEach((step, index) => {
        step.classList.remove('active', 'completed');
        if (index + 1 < AppState.currentStep) {
          step.classList.add('completed');
        } else if (index + 1 === AppState.currentStep) {
          step.classList.add('active');
        }
      });
      
      // Update progress bar
      const progress = (AppState.currentStep / 5) * 100;
      document.querySelector('.progress-fill').style.width = `${progress}%`;
      
      // Show/hide step content
      document.querySelectorAll('.step-content').forEach(content => {
        content.classList.remove('active');
      });
      document.getElementById(`step${AppState.currentStep}`).classList.add('active');
    }

    async function nextStep() {
      if (AppState.currentStep === 1) {
        // Validate at least one image uploaded
        if (!AppState.palmImages.left && !AppState.palmImages.right) {
          showError('ìµœì†Œ í•œ ì†ì˜ ì´ë¯¸ì§€ë¥¼ ì—…ë¡œë“œí•´ì£¼ì„¸ìš”');
          return;
        }
        
        // Move to preprocessing
        AppState.currentStep++;
        updateStepUI();
        await performPreprocessing();
        
      } else if (AppState.currentStep === 2) {
        // Move to Saju input
        AppState.currentStep++;
        updateStepUI();
        
      } else if (AppState.currentStep === 3) {
        // Save Saju data and move to analysis
        saveSajuData();
        AppState.currentStep++;
        updateStepUI();
        
      } else if (AppState.currentStep < 5) {
        AppState.currentStep++;
        updateStepUI();
      }
    }

    function previousStep() {
      if (AppState.currentStep > 1) {
        AppState.currentStep--;
        updateStepUI();
      }
    }

    // ===== Preprocessing =====
    
    async function performPreprocessing() {
      // Process left hand if available
      if (AppState.palmImages.left) {
        AppState.preprocessedData.left = await preprocessImage(AppState.palmImages.left);
        
        // Update UI
        document.getElementById('resolution-value').textContent = 
          AppState.palmImages.quality.left.resolution;
        document.getElementById('contrast-value').textContent = 
          AppState.palmImages.quality.left.contrast + '%';
        document.getElementById('sharpness-value').textContent = 
          AppState.palmImages.quality.left.sharpness + '%';
        document.getElementById('noise-value').textContent = 'ë‚®ìŒ';
      }
      
      // Process right hand if available
      if (AppState.palmImages.right) {
        AppState.preprocessedData.right = await preprocessImage(AppState.palmImages.right);
      }
    }

    // ===== Professional Analysis =====
    
    async function startProfessionalAnalysis() {
      const steps = [
        { id: 'preprocessing', name: 'ì´ë¯¸ì§€ ì „ì²˜ë¦¬', duration: 1500 },
        { id: 'segmentation', name: 'CNN ì„¸ê·¸ë©˜í…Œì´ì…˜', duration: 2000 },
        { id: 'feature-extraction', name: 'íŠ¹ì§• ì¶”ì¶œ', duration: 1800 },
        { id: 'pattern-matching', name: 'íŒ¨í„´ ë§¤ì¹­', duration: 1600 },
        { id: 'report-generation', name: 'ë¦¬í¬íŠ¸ ìƒì„±', duration: 1200 }
      ];
      
      for (const step of steps) {
        const element = document.getElementById(step.id);
        
        // Animate progress
        for (let i = 0; i <= 100; i += 10) {
          element.querySelector('.progress-percentage').textContent = `${i}%`;
          await sleep(step.duration / 10);
        }
        
        element.classList.add('complete');
      }
      
      // Perform actual analysis
      await performFullAnalysis();
      
      // Move to report
      AppState.currentStep = 5;
      updateStepUI();
      renderProfessionalReport();
    }

    async function performFullAnalysis() {
      // Segment lines
      if (AppState.preprocessedData.left) {
        const leftSegmented = segmentPalmLines(AppState.preprocessedData.left);
        AppState.extractedFeatures.left = extractDetailedFeatures(leftSegmented);
      }
      
      if (AppState.preprocessedData.right) {
        const rightSegmented = segmentPalmLines(AppState.preprocessedData.right);
        AppState.extractedFeatures.right = extractDetailedFeatures(rightSegmented);
      }
      
      // Generate interpretations
      const leftInterpretation = AppState.extractedFeatures.left ? 
        generateProfessionalInterpretation(AppState.extractedFeatures.left) : null;
      const rightInterpretation = AppState.extractedFeatures.right ?
        generateProfessionalInterpretation(AppState.extractedFeatures.right) : null;
      
      // Calculate domain scores
      const domainScores = calculateDomainScores(
        AppState.extractedFeatures.left,
        AppState.extractedFeatures.right
      );
      
      // Generate life phase predictions
      const lifePhasePredictions = generateLifePhasePredictions(
        AppState.extractedFeatures.right || AppState.extractedFeatures.left
      );
      
      // Store results
      AppState.analysisResults = {
        leftInterpretation,
        rightInterpretation,
        domainScores,
        lifePhasePredictions,
        overallScore: Math.round(
          Object.values(domainScores).reduce((a, b) => a + b, 0) / 
          Object.keys(domainScores).length
        ),
        confidence: calculateConfidence()
      };
    }

    function calculateConfidence() {
      let confidence = 60;
      
      // Image quality affects confidence
      if (AppState.palmImages.quality.left) {
        confidence += AppState.palmImages.quality.left.score * 0.15;
      }
      if (AppState.palmImages.quality.right) {
        confidence += AppState.palmImages.quality.right.score * 0.15;
      }
      
      // Both hands increase confidence
      if (AppState.palmImages.left && AppState.palmImages.right) {
        confidence += 10;
      }
      
      // Saju data increases confidence
      if (AppState.sajuData.year) {
        confidence += 5;
      }
      
      return Math.min(95, Math.round(confidence));
    }

    // ===== Report Rendering =====
    
    function renderProfessionalReport() {
      const results = AppState.analysisResults;
      
      // Warning banner
      document.getElementById('global-banners').innerHTML = `
        <div class="banner warn">
          <strong>âš ï¸ ì£¼ì˜:</strong> ë³¸ ë¶„ì„ì€ ì°¸ê³ ìš©ì´ë©°, ì˜í•™ì Â·ë²•ë¥ ì  ì¡°ì–¸ì„ ëŒ€ì²´í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.
          ì‹ ë¢°ë„: ${results.confidence}%
        </div>
      `;
      
      // Score cards
      renderScoreCards(results.domainScores, results.overallScore);
      
      // Main lines analysis
      renderMainLinesAnalysis(results.rightInterpretation || results.leftInterpretation);
      
      // Auxiliary lines analysis
      renderAuxiliaryLinesAnalysis();
      
      // Professional interpretation
      renderProfessionalInterpretation(results.domainScores);
      
      // Life phase predictions
      renderLifePhasePredictions(results.lifePhasePredictions);
    }

    function renderScoreCards(domainScores, overallScore) {
      const grid = document.getElementById('result-grid');
      
      grid.innerHTML = `
        <div class="result-card clickable" data-domain="overall">
          <div class="result-score">${overallScore}</div>
          <div class="result-label">ì¢…í•© ì ìˆ˜</div>
        </div>
      `;
      
      const domainNames = {
        career: 'ê²½ë ¥/ì„±ê³µ',
        wealth: 'ì¬ë¬¼ìš´',
        love: 'ì• ì •ìš´',
        health: 'ê±´ê°•ìš´',
        personality: 'ì„±ê²©/ê¸°ì§ˆ'
      };
      
      Object.entries(domainScores).forEach(([domain, score]) => {
        grid.innerHTML += `
          <div class="result-card clickable" data-domain="${domain}">
            <div class="result-score">${score}</div>
            <div class="result-label">${domainNames[domain]}</div>
          </div>
        `;
      });
      
      // Add click handlers
      grid.addEventListener('click', (e) => {
        const card = e.target.closest('.result-card');
        if (card) {
          showDetailModal(card.dataset.domain);
        }
      });
    }

    function renderMainLinesAnalysis(interpretation) {
      const container = document.getElementById('main-lines-analysis');
      
      const mainLines = ['lifeLine', 'headLine', 'heartLine', 'fateLine'];
      
      mainLines.forEach(lineKey => {
        const lineData = interpretation?.[lineKey];
        if (!lineData) return;
        
        const html = `
          <div class="line-analysis">
            <h4>
              ${lineData.name}
              <span class="line-badge">ì‹ ë¢°ë„ ${Math.round((lineData.confidence || 0.8) * 100)}%</span>
            </h4>
            <ul class="feature-list">
              <li>
                <span class="feature-label">ê¸¸ì´</span>
                <span class="feature-value">${Math.round(lineData.features?.length || 0)}px</span>
              </li>
              <li>
                <span class="feature-label">ê¹Šì´</span>
                <span class="feature-value">${((lineData.features?.depth || 0) * 100).toFixed(1)}%</span>
              </li>
              <li>
                <span class="feature-label">íŠ¹ì§•</span>
                <span class="feature-value">${lineData.interpretation.join(', ')}</span>
              </li>
            </ul>
          </div>
        `;
        
        container.innerHTML += html;
      });
    }

    function renderAuxiliaryLinesAnalysis() {
      const container = document.getElementById('auxiliary-lines-analysis');
      
      // Simulate auxiliary lines detection
      const auxiliaryLines = {
        sunLine: { detected: Math.random() > 0.5, interpretation: 'ì„±ê³µê³¼ ëª…ì˜ˆì˜ ê°€ëŠ¥ì„±' },
        mercuryLine: { detected: Math.random() > 0.7, interpretation: 'ì‚¬ì—… ìˆ˜ì™„' },
        marriageLines: { count: Math.floor(Math.random() * 3) + 1, interpretation: 'ê¹Šì€ ì¸ì—°' },
        childrenLines: { count: Math.floor(Math.random() * 4), interpretation: 'ìë…€ìš´' },
        intuitionLine: { detected: Math.random() > 0.8, interpretation: 'ì§ê´€ë ¥' }
      };
      
      let html = '<ul class="feature-list">';
      
      Object.entries(auxiliaryLines).forEach(([key, data]) => {
        if (data.detected || data.count > 0) {
          html += `
            <li>
              <span class="feature-label">${PALM_LINES_DB[key]?.name || key}</span>
              <span class="feature-value">${data.interpretation}</span>
            </li>
          `;
        }
      });
      
      html += '</ul>';
      container.innerHTML = html;
    }

    function renderProfessionalInterpretation(domainScores) {
      const container = document.getElementById('interpretation-grid');
      
      const interpretations = {
        career: {
          title: 'ê²½ë ¥ê³¼ ì„±ê³µ',
          high: 'ê°•í•œ ì•¼ë§ê³¼ ë¦¬ë”ì‹­ì„ ë³´ìœ í•˜ê³  ìˆìœ¼ë©°, ëª©í‘œ ë‹¬ì„± ëŠ¥ë ¥ì´ ë›°ì–´ë‚©ë‹ˆë‹¤.',
          medium: 'ì•ˆì •ì ì¸ ê²½ë ¥ ë°œì „ì´ ì˜ˆìƒë˜ë©°, ê¾¸ì¤€í•œ ë…¸ë ¥ìœ¼ë¡œ ì„±ê³¼ë¥¼ ì–»ì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤.',
          low: 'ê²½ë ¥ì— ëŒ€í•œ ì¬ê²€í† ê°€ í•„ìš”í•˜ë©°, ìƒˆë¡œìš´ ê¸°íšŒë¥¼ ëª¨ìƒ‰í•˜ëŠ” ê²ƒì´ ì¢‹ìŠµë‹ˆë‹¤.'
        },
        wealth: {
          title: 'ì¬ë¬¼ê³¼ í’ìš”',
          high: 'ì¬ë¬¼ ì¶•ì  ëŠ¥ë ¥ì´ ë›°ì–´ë‚˜ë©°, ë‹¤ì–‘í•œ ìˆ˜ì…ì›ì„ ê°œë°œí•  ê°€ëŠ¥ì„±ì´ ë†’ìŠµë‹ˆë‹¤.',
          medium: 'ì•ˆì •ì ì¸ ì¬ì • ìƒíƒœë¥¼ ìœ ì§€í•  ìˆ˜ ìˆìœ¼ë©°, ê³„íšì ì¸ ê´€ë¦¬ê°€ ì¤‘ìš”í•©ë‹ˆë‹¤.',
          low: 'ì¬ì • ê´€ë¦¬ì— ë” ë§ì€ ì£¼ì˜ê°€ í•„ìš”í•˜ë©°, ì¶©ë™ì ì¸ ì§€ì¶œì„ í”¼í•´ì•¼ í•©ë‹ˆë‹¤.'
        },
        love: {
          title: 'ì‚¬ë‘ê³¼ ê´€ê³„',
          high: 'ê¹Šê³  ì˜ë¯¸ ìˆëŠ” ê´€ê³„ë¥¼ í˜•ì„±í•  ëŠ¥ë ¥ì´ ìˆìœ¼ë©°, ê°ì • í‘œí˜„ì´ í’ë¶€í•©ë‹ˆë‹¤.',
          medium: 'ì•ˆì •ì ì¸ ê´€ê³„ë¥¼ ìœ ì§€í•  ìˆ˜ ìˆìœ¼ë©°, ì†Œí†µ ë…¸ë ¥ì´ í•„ìš”í•©ë‹ˆë‹¤.',
          low: 'ê´€ê³„ì—ì„œ ë” ë§ì€ ê°œë°©ì„±ê³¼ ì‹ ë¢°ê°€ í•„ìš”í•˜ë©°, ìê¸° ì„±ì°°ì´ ë„ì›€ì´ ë©ë‹ˆë‹¤.'
        },
        health: {
          title: 'ê±´ê°•ê³¼ í™œë ¥',
          high: 'ê°•í•œ ìƒëª…ë ¥ê³¼ íšŒë³µë ¥ì„ ë³´ìœ í•˜ê³  ìˆìœ¼ë©°, ê±´ê°•í•œ ìƒí™œìŠµê´€ì„ ìœ ì§€í•˜ê³  ìˆìŠµë‹ˆë‹¤.',
          medium: 'ì „ë°˜ì ìœ¼ë¡œ ê±´ê°•í•˜ë‚˜ ìŠ¤íŠ¸ë ˆìŠ¤ ê´€ë¦¬ê°€ í•„ìš”í•˜ë©°, ê·œì¹™ì ì¸ ìš´ë™ì´ ê¶Œì¥ë©ë‹ˆë‹¤.',
          low: 'ê±´ê°•ì— ë” ë§ì€ ê´€ì‹¬ì´ í•„ìš”í•˜ë©°, ì •ê¸°ì ì¸ ê±´ê°• ê²€ì§„ì„ ë°›ëŠ” ê²ƒì´ ì¢‹ìŠµë‹ˆë‹¤.'
        },
        personality: {
          title: 'ì„±ê²©ê³¼ ê¸°ì§ˆ',
          high: 'ê· í˜• ì¡íŒ ì„±ê²©ìœ¼ë¡œ ë‹¤ì–‘í•œ ìƒí™©ì— ì˜ ì ì‘í•˜ë©°, íƒ€ì¸ê³¼ì˜ ì¡°í™”ë¥¼ ì´ë£¹ë‹ˆë‹¤.',
          medium: 'ì•ˆì •ì ì¸ ì„±ê²©ì´ë‚˜ ë•Œë¡œëŠ” ìœ ì—°ì„±ì´ í•„ìš”í•˜ë©°, ìƒˆë¡œìš´ ê²½í—˜ì— ê°œë°©ì ì´ì–´ì•¼ í•©ë‹ˆë‹¤.',
          low: 'ìê¸° ì´í•´ì™€ ì„±ì¥ì´ í•„ìš”í•˜ë©°, ê°ì • ì¡°ì ˆ ëŠ¥ë ¥ì„ í–¥ìƒì‹œí‚¤ëŠ” ê²ƒì´ ë„ì›€ì´ ë©ë‹ˆë‹¤.'
        }
      };
      
      Object.entries(domainScores).forEach(([domain, score]) => {
        const interp = interpretations[domain];
        let text;
        
        if (score >= 80) text = interp.high;
        else if (score >= 60) text = interp.medium;
        else text = interp.low;
        
        container.innerHTML += `
          <div class="interpretation-card">
            <h4>ğŸ¯ ${interp.title}</h4>
            <p>${text}</p>
            <p style="margin-top: 10px; font-size: 0.9rem; opacity: 0.8;">
              ì ìˆ˜: ${score}/100
            </p>
          </div>
        `;
      });
    }

    function renderLifePhasePredictions(predictions) {
      const container = document.getElementById('life-phase-analysis');
      
      let html = '<div style="padding: 15px;">';
      
      predictions.forEach(phase => {
        html += `
          <div style="margin-bottom: 20px; padding: 15px; background: var(--light); border-radius: 10px;">
            <h4 style="color: var(--primary); margin-bottom: 8px;">${phase.age}</h4>
            <p style="font-weight: 600; margin-bottom: 5px;">${phase.prediction}</p>
            <p style="font-size: 0.95rem; color: #666;">${phase.details}</p>
            ${phase.health ? `<p style="font-size: 0.9rem; color: var(--success); margin-top: 5px;">âœ“ ${phase.health}</p>` : ''}
          </div>
        `;
      });
      
      html += '</div>';
      container.innerHTML = html;
    }

    // ===== Event Handlers =====
    
    async function handleImageUpload(file, hand) {
      if (!file) return;
      
      const reader = new FileReader();
      reader.onload = async (e) => {
        const dataUrl = e.target.result;
        
        // Evaluate image quality
        const quality = await evaluateImageQuality(dataUrl);
        
        // Store image and quality
        AppState.palmImages[hand] = dataUrl;
        AppState.palmImages.quality[hand] = quality;
        
        // Update UI
        updateImagePreview(hand, dataUrl, quality);
      };
      reader.readAsDataURL(file);
    }

    function updateImagePreview(hand, dataUrl, quality) {
      const preview = document.getElementById(`${hand}-preview`);
      const badge = document.getElementById(`${hand}-quality`);
      const card = preview.closest('.upload-card');
      
      // Show preview
      preview.src = dataUrl;
      preview.classList.add('visible');
      card.classList.add('has-image');
      
      // Update quality badge
      let qualityClass = 'quality-low';
      let qualityText = 'ë‚®ìŒ';
      
      if (quality.score >= 80) {
        qualityClass = 'quality-high';
        qualityText = 'ë†’ìŒ';
      } else if (quality.score >= 60) {
        qualityClass = 'quality-medium';
        qualityText = 'ë³´í†µ';
      }
      
      badge.className = `quality-badge ${qualityClass}`;
      badge.textContent = `í’ˆì§ˆ: ${qualityText} (${quality.score})`;
    }

    function saveSajuData() {
      AppState.sajuData = {
        year: document.getElementById('birth-year').value,
        month: document.getElementById('birth-month').value,
        day: document.getElementById('birth-day').value,
        hour: document.getElementById('birth-hour').value,
        gender: document.getElementById('gender').value,
        isLunar: document.getElementById('lunar-calendar').checked
      };
    }

    function showDetailModal(domain) {
      const modal = document.getElementById('detail-modal');
      const title = document.getElementById('modal-title');
      const body = document.getElementById('modal-body');
      
      const domainNames = {
        overall: 'ì¢…í•© ë¶„ì„',
        career: 'ê²½ë ¥ê³¼ ì„±ê³µ',
        wealth: 'ì¬ë¬¼ìš´',
        love: 'ì• ì •ìš´',
        health: 'ê±´ê°•ìš´',
        personality: 'ì„±ê²©ê³¼ ê¸°ì§ˆ'
      };
      
      title.textContent = domainNames[domain];
      
      // Generate detailed content
      body.innerHTML = `
        <h3>ìƒì„¸ ë¶„ì„ ê²°ê³¼</h3>
        <p>ì´ ì˜ì—­ì— ëŒ€í•œ ì‹¬ì¸µ ë¶„ì„ ë‚´ìš©ì´ ì—¬ê¸°ì— í‘œì‹œë©ë‹ˆë‹¤.</p>
      `;
      
      modal.classList.add('active');
      document.body.style.overflow = 'hidden';
    }

    function closeModal() {
      document.getElementById('detail-modal').classList.remove('active');
      document.body.style.overflow = '';
    }

    function resetAnalysis() {
      if (!confirm('ëª¨ë“  ë¶„ì„ ë‚´ìš©ì´ ì´ˆê¸°í™”ë©ë‹ˆë‹¤. ê³„ì†í•˜ì‹œê² ìŠµë‹ˆê¹Œ?')) {
        return;
      }
      
      // Reset state
      AppState.currentStep = 1;
      AppState.palmImages = { left: null, right: null, quality: { left: null, right: null } };
      AppState.preprocessedData = { left: null, right: null };
      AppState.sajuData = {};
      AppState.analysisResults = null;
      AppState.extractedFeatures = { left: null, right: null };
      
      // Reset UI
      updateStepUI();
      
      // Clear images
      ['left', 'right'].forEach(hand => {
        const preview = document.getElementById(`${hand}-preview`);
        const badge = document.getElementById(`${hand}-quality`);
        const card = preview.closest('.upload-card');
        
        preview.src = '';
        preview.classList.remove('visible');
        card.classList.remove('has-image');
        badge.textContent = '';
      });
      
      // Clear form
      document.getElementById('saju-form').reset();
      
      // Clear analysis progress
      document.querySelectorAll('.analysis-step').forEach(step => {
        step.classList.remove('complete');
        step.querySelector('.progress-percentage').textContent = '0%';
      });
      
      // Clear results
      document.getElementById('result-grid').innerHTML = '';
      document.getElementById('main-lines-analysis').innerHTML = '';
      document.getElementById('auxiliary-lines-analysis').innerHTML = '';
      document.getElementById('interpretation-grid').innerHTML = '';
      document.getElementById('life-phase-analysis').innerHTML = '';
      document.getElementById('global-banners').innerHTML = '';
    }

    function exportProfessionalReport() {
      if (!AppState.analysisResults) {
        showError('ë‚´ë³´ë‚¼ ë¦¬í¬íŠ¸ê°€ ì—†ìŠµë‹ˆë‹¤');
        return;
      }
      
      // Generate CSV
      const results = AppState.analysisResults;
      const csv = [
        ['PalmAI Pro Professional Report'],
        ['ìƒì„±ì¼ì‹œ', new Date().toLocaleString()],
        ['ì‹ ë¢°ë„', results.confidence + '%'],
        [''],
        ['ì˜ì—­', 'ì ìˆ˜'],
        ['ì¢…í•©', results.overallScore],
        ...Object.entries(results.domainScores).map(([domain, score]) => [domain, score]),
        [''],
        ['ìƒì• ì£¼ê¸° ì˜ˆì¸¡'],
        ...results.lifePhasePredictions.map(phase => [phase.age, phase.prediction])
      ].map(row => row.join(',')).join('\n');
      
      const blob = new Blob(['\ufeff' + csv], { type: 'text/csv;charset=utf-8;' });
      const link = document.createElement('a');
      link.href = URL.createObjectURL(blob);
      link.download = `PalmAI_Professional_Report_${new Date().toISOString().slice(0,10)}.csv`;
      link.click();
    }

    function showError(message) {
      const banner = document.createElement('div');
      banner.className = 'banner error';
      banner.innerHTML = `<strong>ì˜¤ë¥˜:</strong> ${message}`;
      
      const container = document.querySelector('.step-content.active');
      container.insertBefore(banner, container.querySelector('.btn-group'));
      
      setTimeout(() => banner.remove(), 5000);
    }

    function sleep(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }

    // ===== Initialization =====
    
    document.addEventListener('DOMContentLoaded', () => {
      // Upload handlers
      document.getElementById('left-hand-input').addEventListener('change', (e) => {
        handleImageUpload(e.target.files[0], 'left');
      });
      
      document.getElementById('right-hand-input').addEventListener('change', (e) => {
        handleImageUpload(e.target.files[0], 'right');
      });
      
      // Step navigation
      document.querySelectorAll('.step').forEach(step => {
        step.addEventListener('click', () => {
          const targetStep = parseInt(step.dataset.step);
          if (targetStep <= AppState.currentStep) {
            AppState.currentStep = targetStep;
            updateStepUI();
          }
        });
      });
      
      // ESC to close modal
      document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape') {
          closeModal();
        }
      });
    });
  </script>
</body>
</html>